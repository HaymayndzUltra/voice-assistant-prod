[
  {
    "id": "20250807_moc_implementation",
    "description": "Action plan to implement, test, and deploy the ModelOps Coordinator (MOC), unifying six legacy agents for model lifecycle, inference, and resource management.",
    "todos": [
      {
        "text": "PHASE 0: SETUP & PROTOCOL (READ FIRST)\n\n**Explanations:**\nThis initial step contains the user manual for this task plan. It outlines the commands to interact with the plan and the critical safety workflow that must be followed for all subsequent phases.\n\n**Technical Artifacts:**\n**I. CORE BEHAVIORAL MANDATES**\n*   **Execute Serially:** You must execute the phases in the prescribed order. Do not skip phases.\n*   **Verify Each Step:** After completing a phase, verify its success before marking it as 'done'.\n*   **Consult Source:** This plan is an interpretation of the source document. If any ambiguity arises, the source document is the ground truth.\n\n**II. HOW TO USE THIS TASK PLAN**\n*   **To Show the Plan:** `python3 todo_manager.py show 20250807_moc_implementation`\n*   **To Mark a Phase Done:** `python3 todo_manager.py done 20250807_moc_implementation <phase_number>` (e.g., `... done 20250807_moc_implementation 0`)\n\n**Concluding Step: Update Plan Status**\nTo officially conclude this setup phase and update the plan's state, run the following commands. This ensures the task manager knows you are ready to proceed to the first technical phase.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_moc_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_moc_implementation 0`\n\n──────────────────────────────────\nIMPORTANT NOTE: This phase contains the operating manual for the entire plan. Understanding these protocols is mandatory before proceeding to Phase 1. Do not proceed until the current step is complete. Before moving forward, review the completed step and the next one. Repeat the review if your confidence score is below 90%.",
        "done": false
      },
      {
        "text": "PHASE 1: Project Scaffolding & Dependencies\n\n**Explanations:**\nThis phase involves creating the complete directory structure for the ModelOps Coordinator, populating the `requirements.txt` file, and installing all necessary dependencies.\n\n**Technical Artifacts / Tasks:**\n**I. Create Directory Structure:**\nExecute `mkdir model_ops_coordinator` and create the following file and directory layout. Create empty `__init__.py` files in each subdirectory.\n```\nmodel_ops_coordinator/\n├── __init__.py\n├── app.py\n├── config/\n│   ├── __init__.py\n│   ├── default.yaml\n│   ├── main_pc.yaml\n│   └── pc2.yaml\n├── core/\n│   ├── __init__.py\n│   ├── kernel.py, lifecycle.py, inference.py, gpu_manager.py, learning.py, goal_manager.py, telemetry.py, schemas.py, errors.py\n├── adapters/\n│   ├── __init__.py\n│   ├── local_worker.py, remote_worker.py, scheduler_client.py\n├── resiliency/\n│   ├── __init__.py\n│   ├── circuit_breaker.py, bulkhead.py\n├── transport/\n│   ├── __init__.py\n│   ├── zmq_server.py, grpc_server.py, rest_api.py\n├── proto/\n│   └── model_ops.proto\n├── requirements.txt\n└── README.md\n```\n\n**II. Copy Best-Practice Modules:**\nCopy the canonical resiliency and utility modules into the project.\n`cp <path_to_common>/resiliency/bulkhead.py model_ops_coordinator/resiliency/`\n`cp <path_to_common>/resiliency/circuit_breaker.py model_ops_coordinator/resiliency/`\n`cp <path_to_common>/utils/network_util.py model_ops_coordinator/`\n\n**III. Populate `requirements.txt`:**\nAdd the following content to `model_ops_coordinator/requirements.txt`.\n```\npydantic==1.10.13\npyzmq==26.0.3\ngrpcio==1.63.0\ngrpcio-tools==1.63.0\nfastapi==0.111.0\nuvicorn==0.29.0\nprometheus-client==0.20.0\ntenacity==8.2.3\ntorch==2.3.0\npsutil==5.9.8\ngpustat==1.1.1\nredis==5.0.1\n```\n\n**IV. Install Dependencies:**\nRun `pip install -r model_ops_coordinator/requirements.txt`.\n\n**Concluding Step: Update Plan Status**\nAfter all technical tasks in this phase are successfully completed, run the following commands to mark this phase as done and prepare for the next one.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_moc_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_moc_implementation 1`\n\n──────────────────────────────────\nIMPORTANT NOTE: A correct project structure and fully installed dependencies are foundational. Verify all files exist and `pip install` completes without errors before proceeding.",
        "done": false
      },
      {
        "text": "PHASE 2: Configuration, Schemas & gRPC Compilation\n\n**Explanations:**\nDefine the application's configuration schema, create the data transfer objects (DTOs) and API contracts in Protobuf, and compile the gRPC stubs.\n\n**Technical Artifacts / Tasks:**\n**I. Define Configuration Schema (`config/default.yaml`):**\nPopulate `model_ops_coordinator/config/default.yaml` with the following content.\n```yaml\ntitle: ModelOpsCoordinatorConfig\nversion: 1.0\n\nserver:\n  zmq_port: 7211\n  grpc_port: 7212\n  rest_port: 8008\n  max_workers: 16\n\nresources:\n  gpu_poll_interval: 5\n  vram_soft_limit_mb: 22000\n  eviction_threshold_pct: 90\n\nmodels:\n  preload:\n    - name: \"llama-7b-chat\"\n      path: \"/models/llama-7b-chat.gguf\"\n      shards: 1\n    - name: \"whisper-base\"\n      path: \"/models/whisper-base.bin\"\n      shards: 1\n  default_dtype: \"float16\"\n  quantization: true\n\nlearning:\n  enable_auto_tune: true\n  max_parallel_jobs: 2\n  job_store: \"${LEARNING_STORE:/workspace/learning_jobs.db}\"\n\ngoals:\n  policy: \"priority_queue\"\n  max_active_goals: 10\n\nresilience:\n  circuit_breaker:\n    failure_threshold: 4\n    reset_timeout: 20\n  bulkhead:\n    max_concurrent: 64\n    max_queue_size: 256\n```\n\n**II. Define gRPC Service (`proto/model_ops.proto`):**\nCreate the Protobuf file with the service definition.\n```proto\nservice ModelOps {\n  rpc Infer (InferenceRequest) returns (InferenceResponse);\n  rpc LoadModel (ModelLoadRequest) returns (ModelLoadReply);\n  rpc UnloadModel (ModelUnloadRequest) returns (ModelUnloadReply);\n  rpc ListModels (google.protobuf.Empty) returns (ModelList);\n}\n```\n\n**III. Compile gRPC Stubs:**\nRun the following command from the project root.\n`python -m grpc_tools.protoc -Iproto --python_out=model_ops_coordinator/ --grpc_python_out=model_ops_coordinator/ proto/model_ops.proto`\n\n**IV. Define Pydantic Schemas (`core/schemas.py`):**\nImplement the Pydantic models for internal data transfer and for the REST API.\n\n**Concluding Step: Update Plan Status**\nAfter all technical tasks in this phase are successfully completed, run the following commands to mark this phase as done and prepare for the next one.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_moc_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_moc_implementation 2`\n\n──────────────────────────────────\nIMPORTANT NOTE: The configuration, schemas, and API contracts are the backbone of the service. Ensure the YAML is valid and the gRPC stubs are generated correctly before implementing the core logic.",
        "done": false
      },
      {
        "text": "PHASE 3: Core Logic & Micro-kernel Implementation\n\n**Explanations:**\nImplement the core business logic of the MOC, including the micro-kernel and all its functional modules for managing GPUs, models, inference, learning, and goals.\n\n**Technical Artifacts / Tasks:**\n**I. Implement Kernel (`core/kernel.py`):**\nCreate the `Kernel` class to initialize and connect all other core modules.\n```python\nclass Kernel:\n    def __init__(self, cfg: Config):\n        self.cfg = cfg\n        self.executor = ThreadPoolExecutor(\n            max_workers=cfg.server.max_workers,\n            thread_name_prefix='ModelOpsWorker'\n        )\n        self.metrics = Telemetry()\n        self.gpu_manager = GPUManager(cfg, self.metrics)\n        self.lifecycle = LifecycleModule(cfg, self.gpu_manager, self.metrics)\n        self.inference = InferenceModule(cfg, self.lifecycle, self.metrics)\n        self.learning = LearningModule(cfg, self.lifecycle, self.metrics)\n        self.goals = GoalModule(cfg, self.learning, self.metrics)\n```\n\n**II. Implement Core Modules:**\n*   **`core/gpu_manager.py`**: Implement VRAM polling, allocation map in Redis, and eviction logic.\n*   **`core/lifecycle.py`**: Implement `load`, `unload`, and `ensure_loaded` methods with circuit breakers. Handle model preloading.\n*   **`core/inference.py`**: Implement the `infer` method with bulkhead guards, using the kernel's executor to run inference.\n*   **`core/learning.py`**: Implement the SQLite-backed job store for fine-tuning/RLHF jobs.\n*   **`core/goal_manager.py`**: Implement the goal priority queue and CRUD operations.\n*   **`core/telemetry.py`**: Define Prometheus counters and gauges.\n*   **`core/errors.py`**: Define custom exceptions like `ModelLoadError` and `GPUUnavailable`.\n\n**Concluding Step: Update Plan Status**\nAfter all technical tasks in this phase are successfully completed, run the following commands to mark this phase as done and prepare for the next one.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_moc_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_moc_implementation 3`\n\n──────────────────────────────────\nIMPORTANT NOTE: This phase contains the most complex logic. Pay close attention to the dependencies between modules (e.g., Inference depends on Lifecycle, which depends on GPUManager).",
        "done": false
      },
      {
        "text": "PHASE 4: Transport Layer Implementation\n\n**Explanations:**\nImplement the server façades (gRPC, ZMQ, REST) that expose the kernel's functionality to the outside world.\n\n**Technical Artifacts / Tasks:**\n**I. Implement gRPC Server (`transport/grpc_server.py`):**\nUsing the stubs generated in Phase 2, implement the `ModelOps` service. Each RPC call should delegate to the appropriate method in the `kernel`'s modules.\n\n**II. Implement ZMQ Server (`transport/zmq_server.py`):**\nCreate a REQ/REP server as a compatibility façade for legacy agents. It should parse `{ \"action\": \"...\", \"payload\": ... }` messages and call the kernel.\n\n**III. Implement REST API (`transport/rest_api.py`):**\nUse FastAPI to create the REST server. Expose the following endpoints:\n*   `/health`\n*   `/metrics` (for Prometheus)\n*   `/goals/*`\n*   `/learning/jobs/*`\n\n**Concluding Step: Update Plan Status**\nAfter all technical tasks in this phase are successfully completed, run the following commands to mark this phase as done and prepare for the next one.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_moc_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_moc_implementation 4`\n\n──────────────────────────────────\nIMPORTANT NOTE: The transport layer is the public interface of your service. Ensure all three servers correctly initialize and delegate requests to the kernel to avoid communication bottlenecks.",
        "done": false
      },
      {
        "text": "PHASE 5: Application Bootstrap & Entry-point\n\n**Explanations:**\nCreate the main application entry-point (`app.py`) that loads configuration, initializes the kernel, and starts all servers concurrently with graceful shutdown handling.\n\n**Technical Artifacts / Tasks:**\n**I. Implement `app.py`:**\nThe script must perform the following actions:\n1.  Use `UnifiedConfigLoader` to load configuration from YAML files and environment variables.\n2.  Instantiate the `Kernel(cfg)`.\n3.  Create an `async def start_servers(cfg, kernel)` function that gathers tasks for starting the gRPC, ZMQ, and REST servers.\n4.  Run the `start_servers` function using `asyncio.run()`.\n5.  Implement graceful shutdown handlers for `SIGTERM`/`SIGINT` to flush the executor and save job states.\n\n**Concluding Step: Update Plan Status**\nAfter all technical tasks in this phase are successfully completed, run the following commands to mark this phase as done and prepare for the next one.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_moc_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_moc_implementation 5`\n\n──────────────────────────────────\nIMPORTANT NOTE: The bootstrap process is critical for service stability. Thoroughly test the startup sequence and the graceful shutdown logic to prevent resource leaks or data corruption.",
        "done": false
      },
      {
        "text": "PHASE 6: Testing & Containerization\n\n**Explanations:**\nConduct comprehensive testing to ensure the service is correct and robust. Package the application into a Docker container for deployment.\n\n**Technical Artifacts / Tasks:**\n**I. Static Analysis:**\nRun and pass checks with `ruff`, `flake8`, and `mypy --strict`.\n\n**II. Unit & Integration Testing:**\n*   Write `pytest` unit tests for core modules (lifecycle, GPU manager with mocks, etc.).\n*   Write an integration test sending 500 concurrent gRPC `Infer` calls, and verify the p95 latency is < 50 ms.\n\n**III. Containerize Application:**\nCreate a `Dockerfile` using a multi-stage build approach (e.g., using `python:3.10` for building and `python:3.10-slim` for the final production image).\n\n**Concluding Step: Update Plan Status**\nAfter all technical tasks in this phase are successfully completed, run the following commands to mark this phase as done and prepare for the next one.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_moc_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_moc_implementation 6`\n\n──────────────────────────────────\nIMPORTANT NOTE: Do not proceed to deployment without passing all tests and having a functional Docker image. This step ensures the application is reliable and portable.",
        "done": false
      },
      {
        "text": "PHASE 7: Final Verification, Deployment & Cut-over\n\n**Explanations:**\nPerform final pre-production checks, deploy the service, migrate traffic from legacy agents, and formally decommission them.\n\n**Technical Artifacts / Tasks:**\n**I. Final Verification Gate:**\nExecute and confirm success for every item on this checklist:\n*   **Benchmark:** 1k rps mixed `Infer` + 50 model loads. Verify CPU < 65%, VRAM ≤ soft limit, p99 < 120 ms.\n*   **HA Test:** Kill the primary replica; ensure the second handles traffic seamlessly.\n*   **Rollback Simulation:** Verify a zero-downtime fallback to a legacy agent is possible.\n*   **Security:** Confirm gRPC TLS is enabled and REST endpoints are protected.\n*   **Documentation:** Generate OpenAPI spec, gRPC docs, and a Prometheus metrics list.\n\n**II. Review Risk Mitigation Checklist:**\nConfirm mitigations are in place for all identified risks (VRAM fragmentation, load storms, etc.).\n\n**III. Deployment & Cut-over:**\n1.  Deploy two replicas per host using the Docker image (via `docker-compose` or Kubernetes).\n2.  Update dependent agents' environment variables to point to the new MOC ports.\n3.  Monitor system stability.\n4.  Once stable, decommission the six superseded agents.\n\n**Concluding Step: Update Plan Status**\nAfter all technical tasks in this phase are successfully completed, run the following commands to mark this phase as done and prepare for the next one.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_moc_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_moc_implementation 7`\n\n──────────────────────────────────\nIMPORTANT NOTE: This is the final production-readiness gate. Be methodical during verification and migration. Successful completion of this phase marks the project as complete and the legacy systems as retired.",
        "done": false
      }
    ],
    "status": "in_progress",
    "created": "2024-05-24T14:15:00Z",
    "updated": "2024-05-24T14:15:00Z"
  },
  {
    "id": "20250807_rtap_implementation",
    "description": "Action plan to implement the Real-Time Audio Pipeline (RTAP), merging six legacy agents into a single, ultra-low-latency service with a target latency of ≤ 150 ms.",
    "todos": [
      {
        "text": "PHASE 8: SETUP & PROTOCOL (READ FIRST)\n\n**Explanations:**\nThis initial step contains the user manual for this task plan. It outlines the commands to interact with the plan and the critical safety workflow that must be followed for all subsequent phases.\n\n**Technical Artifacts:**\n**I. CORE BEHAVIORAL MANDATES**\n*   **Execute Serially:** You must execute the phases in the prescribed order. Do not skip phases.\n*   **Verify Each Step:** After completing a phase, verify its success before marking it as 'done'.\n*   **Consult Source:** This plan is an interpretation of the source document. If any ambiguity arises, the source document is the ground truth.\n\n**II. HOW TO USE THIS TASK PLAN**\n*   **To Show the Plan:** `python3 todo_manager.py show 20250807_rtap_implementation`\n*   **To Mark a Phase Done:** `python3 todo_manager.py done 20250807_rtap_implementation <phase_number>` (e.g., `... done 20250807_rtap_implementation 0`)\n\n**Concluding Step: Update Plan Status**\nTo officially conclude this setup phase and update the plan's state, run the following commands. This ensures the task manager knows you are ready to proceed to the first technical phase.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_rtap_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_rtap_implementation 0`\n\n──────────────────────────────────\nIMPORTANT NOTE: This phase contains the operating manual for the entire plan. Understanding these protocols is mandatory before proceeding to Phase 1. Do not proceed until the current step is complete. Before moving forward, review the completed step and the next one. Repeat the review if your confidence score is below 90%.",
        "done": false
      },
      {
        "text": "PHASE 9: Project Scaffolding & Dependencies\n\n**Explanations:**\nThis phase involves creating the directory structure for the Real-Time Audio Pipeline, copying essential resiliency modules, and setting up the Python environment with all required dependencies.\n\n**Technical Artifacts / Tasks:**\n**I. Create Directory Structure:**\nCreate the following directory and file layout. Empty `__init__.py` files should be created in each subdirectory.\n```\nreal_time_audio_pipeline/\n├── __init__.py\n├── app.py\n├── config/\n│   ├── __init__.py\n│   ├── default.yaml\n│   ├── main_pc.yaml\n│   └── pc2.yaml\n├── core/\n│   ├── __init__.py\n│   ├── pipeline.py\n│   ├── stages/\n│   │   ├── __init__.py\n│   │   ├── capture.py, preprocess.py, wakeword.py, stt.py, language.py, utils.py\n│   ├── buffers.py\n│   └── telemetry.py\n├── transport/\n│   ├── __init__.py\n│   ├── zmq_pub.py\n│   └── ws_server.py\n├── resiliency/\n│   ├── __init__.py\n│   ├── circuit_breaker.py\n│   └── bulkhead.py\n├── proto/\n│   └── transcript.proto\n├── requirements.txt\n└── README.md\n```\n\n**II. Copy Resiliency Utilities:**\nCopy the canonical `bulkhead.py` and `circuit_breaker.py` modules into `real_time_audio_pipeline/resiliency/`.\n\n**III. Populate `requirements.txt`:**\nAdd the following dependencies to `real_time_audio_pipeline/requirements.txt`.\n```\nnumpy==1.26.4\nsounddevice==0.4.7\npyzmq==26.0.3\nwebrtcvad==2.0.10\npvporcupine==2.3.1\nwhisper-timestamped==1.14\nfasttext-wheel==0.9.2\ntorch==2.3.0\ntenacity==8.2.3\npydantic==1.10.13\nfastapi==0.111.0\nuvicorn==0.29.0\nprometheus-client==0.20.0\n```\n\n**IV. Install Dependencies:**\nRun `pip install -r real_time_audio_pipeline/requirements.txt`.\n\n**Concluding Step: Update Plan Status**\nAfter all technical tasks in this phase are successfully completed, run the following commands to mark this phase as done and prepare for the next one.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_rtap_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_rtap_implementation 1`\n\n──────────────────────────────────\nIMPORTANT NOTE: A correct project structure and environment are critical for all subsequent development. Verify that all files are in the correct locations and all dependencies are installed without errors before proceeding.",
        "done": false
      },
      {
        "text": "PHASE 10: Configuration & Core Buffer Implementation\n\n**Explanations:**\nDefine the application's configuration schema and implement the core zero-copy ring buffer that will be used for efficient data hand-off between pipeline stages.\n\n**Technical Artifacts / Tasks:**\n**I. Define Configuration Schema (`config/default.yaml`):**\nPopulate `real_time_audio_pipeline/config/default.yaml` with the following content.\n```yaml\ntitle: RealTimeAudioPipelineConfig\nversion: 1.0\n\naudio:\n  sample_rate: 16000\n  frame_ms: 20\n  channels: 1\n  device: \"${AUDIO_DEVICE:default}\"\n  ring_buffer_size_ms: 4000\n\nwakeword:\n  model_path: \"/models/porcupine/wake.ppn\"\n  sensitivity: 0.55\n\npreprocess:\n  denoise: true\n  vad_aggressiveness: 2\n\nstt:\n  model_name: \"whisper-base\"\n  device: \"cuda\"\n  compute_dtype: \"float16\"\n  beam_size: 5\n\nlanguage:\n  sentiment: true\n  fasttext_model: \"/models/lid.176.bin\"\n\noutput:\n  zmq_pub_port_events: 6552\n  zmq_pub_port_transcripts: 6553\n  websocket_port: 5802\n\nresilience:\n  circuit_breaker:\n    failure_threshold: 3\n    reset_timeout: 15\n  bulkhead:\n    max_concurrent: 8\n    max_queue_size: 32\n```\n\n**II. Implement Ring Buffer (`core/buffers.py`):**\nImplement the `RingBuffer` class using `collections.deque` for efficient, bounded, pre-allocated NumPy buffer management.\n```python\nclass RingBuffer:\n    def __init__(self, max_frames: int, frame_size: int):\n        self.buffer = deque(maxlen=max_frames)\n        ...\n\n    def write(self, frame: np.ndarray): ...\n    def read_all(self) -> np.ndarray: ...\n```\n\n**Concluding Step: Update Plan Status**\nAfter all technical tasks in this phase are successfully completed, run the following commands to mark this phase as done and prepare for the next one.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_rtap_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_rtap_implementation 2`\n\n──────────────────────────────────\nIMPORTANT NOTE: The configuration and the ring buffer are foundational to the entire pipeline's performance and stability. Ensure the buffer logic is correct and tested before building the stages that depend on it.",
        "done": false
      },
      {
        "text": "PHASE 11: Core Pipeline & Stage Implementation\n\n**Explanations:**\nImplement the heart of the RTAP: the master state-machine and the individual asynchronous coroutine stages for audio capture, preprocessing, wake-word detection, STT, and language analysis.\n\n**Technical Artifacts / Tasks:**\n**I. Implement Pipeline State Machine (`core/pipeline.py`):**\nCreate the `AudioPipeline` class to manage the overall state (IDLE, LISTENING, PROCESSING, EMIT) and orchestrate the lifecycle of the stage tasks.\n```python\nclass AudioPipeline:\n    def __init__(self, cfg: Config):\n        self.cfg = cfg\n        self.state = State.IDLE\n        self.buffer = RingBuffer(...)\n        self.tasks: List[asyncio.Task] = []\n\n    async def start(self):\n        await self._spawn_tasks()\n        await self._state_loop()\n    ...\n```\n\n**II. Implement Stage Coroutines (`core/stages/*.py`):**\nImplement each processing stage as a separate, long-running coroutine that communicates via `asyncio.Queue`s or shared buffers.\n*   `capture.py`: Use `sounddevice` to capture audio and write to the ring buffer.\n*   `wakeword.py`: Read from the buffer and use `pvporcupine` to detect the wake-word, changing the pipeline state.\n*   `preprocess.py`: Perform VAD, denoising, and resampling.\n*   `stt.py`: Run Whisper inference, potentially in a `ThreadPoolExecutor` to avoid blocking the event loop.\n*   `language.py`: Run fastText or other language analysis on the transcript.\n\n**III. Implement Telemetry (`core/telemetry.py`):**\nDefine Prometheus counters for key metrics like frames processed, wake-word hits, and histograms for end-to-end pipeline latency.\n\n**Concluding Step: Update Plan Status**\nAfter all technical tasks in this phase are successfully completed, run the following commands to mark this phase as done and prepare for the next one.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_rtap_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_rtap_implementation 3`\n\n──────────────────────────────────\nIMPORTANT NOTE: This phase contains the most complex logic. The interaction between the async stages is critical for meeting the low-latency budget. Test each stage in isolation before integrating it into the main pipeline.",
        "done": false
      },
      {
        "text": "PHASE 12: Transport Layer Implementation\n\n**Explanations:**\nImplement the external interfaces for publishing events and transcripts, including ZeroMQ PUB sockets and an optional FastAPI WebSocket server for browser-based clients.\n\n**Technical Artifacts / Tasks:**\n**I. Implement ZMQ Publishers (`transport/zmq_pub.py`):**\nCreate a `ZmqPublisher` class that starts two PUB sockets on the configured ports (6552 for events, 6553 for transcripts). It should consume from an async generator provided by the pipeline.\n\n**II. Implement WebSocket Server (`transport/ws_server.py`):**\nUsing FastAPI, create a WebSocket endpoint at `/stream`. This server will also consume from the pipeline's async generator and push real-time transcript chunks to connected clients.\n\n**III. Define Transcript Schema:**\nUse a Pydantic model to define the structure of the JSON transcripts published on the ZMQ socket and WebSocket.\n\n**Concluding Step: Update Plan Status**\nAfter all technical tasks in this phase are successfully completed, run the following commands to mark this phase as done and prepare for the next one.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_rtap_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_rtap_implementation 4`\n\n──────────────────────────────────\nIMPORTANT NOTE: The transport layer is the public API of the service. Ensure that data serialization is efficient and the sockets are configured correctly to prevent becoming a performance bottleneck.",
        "done": false
      },
      {
        "text": "PHASE 13: Application Bootstrap & Entry-point\n\n**Explanations:**\nCreate the main application entry-point (`app.py`) that ties everything together: configuration loading, model warm-up, and concurrent startup of the pipeline and transport layers.\n\n**Technical Artifacts / Tasks:**\n**I. Implement `app.py`:**\nThe script must perform the following actions:\n1.  Use `UnifiedConfigLoader` to load configuration.\n2.  Implement an `async def initialize_and_run(cfg)` function.\n3.  Inside this function, warm-up the STT and wake-word models.\n4.  Instantiate the `AudioPipeline`, `ZmqPublisher`, and `WebSocketServer`.\n5.  Use `asyncio.gather` to run the `pipeline.start()`, `zmq_pub.start()`, and `ws_server.serve()` coroutines concurrently.\n6.  Implement graceful shutdown logic to cancel all tasks, close the sound device, and flush any remaining data.\n\n**Concluding Step: Update Plan Status**\nAfter all technical tasks in this phase are successfully completed, run the following commands to mark this phase as done and prepare for the next one.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_rtap_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_rtap_implementation 5`\n\n──────────────────────────────────\nIMPORTANT NOTE: The bootstrap process is critical for service stability. Model warm-up is essential to avoid a long delay on the first request, and graceful shutdown prevents resource leaks.",
        "done": false
      },
      {
        "text": "PHASE 14: Testing & Profiling\n\n**Explanations:**\nConduct comprehensive testing to ensure the pipeline is correct, meets its strict latency budget, and is performant under load.\n\n**Technical Artifacts / Tasks:**\n**I. Unit Tests:**\nWrite and pass `pytest` unit tests for critical components:\n*   Verify the ring buffer's wraparound behavior.\n*   Test the wake-word engine's false-positive rate to ensure it's < 1%.\n\n**II. Latency & Performance Testing:**\n*   **Latency Test:** Record a 30-second audio clip and measure the end-to-end latency from the first audio sample to the final transcript publication. Ensure the mean is < 120 ms.\n*   **Profiling:** Use `py-spy` to profile the running application. Confirm CPU usage is < 20% per core and GPU utilization is stable.\n\n**III. Static Analysis:**\nRun static analysis tools and ensure they pass without warnings.\n*   `mypy --strict`\n*   `ruff`\n\n**Concluding Step: Update Plan Status**\nAfter all technical tasks in this phase are successfully completed, run the following commands to mark this phase as done and prepare for the next one.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_rtap_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_rtap_implementation 6`\n\n──────────────────────────────────\nIMPORTANT NOTE: Meeting the ≤ 150 ms p95 latency budget is the primary goal of this project. Rigorous testing and profiling are non-negotiable. Do not proceed to deployment without passing these checks.",
        "done": false
      },
      {
        "text": "PHASE 15: Final Verification, Deployment & Decommissioning\n\n**Explanations:**\nPerform the final pre-production checks, containerize and deploy the service, and transition downstream agents to the new pipeline before decommissioning the legacy systems.\n\n**Technical Artifacts / Tasks:**\n**I. Dockerize Application:**\nCreate a `Dockerfile` for the service. Ensure it handles audio device access correctly, for example by using `--device /dev/snd` or host networking with ALSA passthrough.\n\n**II. Review Risk Mitigation Checklist:**\nConfirm that mitigations are in place for all identified risks (e.g., buffer overflow, model load delays, GPU starvation, memory leaks).\n\n**III. Execute Final Verification Gate:**\n*   **Latency Benchmark:** Verify end-to-end latency is < 150 ms p95.\n*   **Accuracy Regression:** Ensure Word Error Rate (WER) is ≤ the legacy pipeline and sentiment accuracy is within ±1%.\n*   **Stress Test:** Run with 2 hours of continuous audio. Verify zero unhandled exceptions and memory growth < 5%.\n*   **Failover Test:** Kill the primary pipeline and ensure the hot standby instance takes over correctly.\n*   **Security Check:** Confirm WebSocket is protected and ZMQ sockets are bound to localhost.\n\n**IV. Deploy & Decommission:**\n1.  Deploy one instance on `main_pc` and an optional hot standby on `pc2`.\n2.  Verify downstream agents continue to function correctly with the new pipeline's output on port 6553.\n3.  Once stability is confirmed, safely decommission the six superseded agents.\n\n**Concluding Step: Update Plan Status**\nAfter all technical tasks in this phase are successfully completed, run the following commands to mark this phase as done and prepare for the next one.\n*   **Review Plan Details:** `python3 todo_manager.py show 20250807_rtap_implementation`\n*   **Mark This Phase as Complete:** `python3 todo_manager.py done 20250807_rtap_implementation 7`\n\n──────────────────────────────────\nIMPORTANT NOTE: This is the final gate before the project is considered complete. Be methodical and rigorous during the verification and deployment process. Successful completion of this phase means the RTAP is production-ready.",
        "done": false
      }
    ],
    "status": "in_progress",
    "created": "2024-05-24T14:15:00Z",
    "updated": "2024-05-24T14:15:00Z"
  }
]