[
  {
    "id": "docker_arch_impl_20250810",
    "description": "A phased implementation plan to build, migrate, and manage the entire service fleet according to the FINAL Docker Architecture Blueprint v1.0.",
    "todos": [
      {
        "text": "PHASE 0: SETUP & PROTOCOL (READ FIRST)\n\n**Core Behavioral Mandates:**\n*   **Execute Sequentially:** Phases are designed to be completed in order, as they build upon each other. Do not skip phases.\n*   **Verify Each Step:** After completing a technical task within a phase, verify its success before proceeding.\n*   **Consult Source Document:** This plan is a derivative of the \"FINAL Docker Architecture Blueprint\". Refer back to it for granular details, rationale, and original context.\n\n**How-To/Workflow Protocol:**\nThis plan is managed by a command-line tool (`todo_manager.py`).\n1.  To view the current status of all phases, run: `python3 todo_manager.py show docker_arch_impl_20250810`\n2.  When all tasks within a phase are complete, mark the phase as done using the `done` command specified at the end of that phase's instructions. This is a crucial step for tracking progress.\n\n**Concluding Step: Phase Completion Protocol**\nTo formally conclude this phase, update the plan's state, and prepare for the next, execute the following protocol:\n1.  **Run Command (Mark Complete):** `python3 todo_manager.py done docker_arch_impl_20250810 0`\n2.  **Analyze Next Phase:** Before proceeding, read and understand the 'Explanations' and 'Tasks' for Phase 1.\n\n──────────────────────────────────\nIMPORTANT NOTE: This phase contains the operating manual for this entire plan. Completing it signifies you understand the workflow required to execute the following technical phases successfully.",
        "done": true
      },
      {
        "text": "PHASE 1: BUILD FOUNDATIONAL BASE IMAGES\n\n**Explanations:**\nThis phase creates the core, shared layers of the entire Docker ecosystem as defined in §B of the blueprint. Getting these right is critical, as all ~50 services will be derived from them. The build order must follow the dependency hierarchy.\n\n**Technical Artifacts / Tasks:**\n1.  **Review Risk Register:** Before starting, review the \"Risk Register & Rollback\" (section G) from the blueprint to be aware of potential issues like driver mismatches or cache quotas.\n2.  **Create Base Images:** Build and push the following base images to GHCR in the specified order. Use the tagging convention `ghcr.io/<org>/<family>:YYYYMMDD-<git_sha>`.\n    *   `base-python:3.11-slim`\n    *   `base-utils` (derived from `base-python`)\n    *   `base-cpu-pydeps` (derived from `base-utils`)\n    *   `family-web` (derived from `base-cpu-pydeps`)\n    *   `base-gpu-cu121` (derived from `nvidia/cuda:12.1.1-runtime-ubuntu22.04`)\n    *   `family-torch-cu121` (derived from `base-gpu-cu121`)\n    *   `family-llm-cu121` (derived from `family-torch-cu121`)\n    *   `family-vision-cu121` (derived from `base-gpu-cu121`)\n3.  **Create Legacy Base Image:** Build and push the `legacy-py310-cpu` image for services pending migration.\n4.  **Verify Images on GHCR:** Confirm all images are present in the GitHub Container Registry (`ghcr.io/<org>`) with the correct tags.\n\n**Concluding Step: Phase Completion Protocol**\nTo formally conclude this phase, update the plan's state, and prepare for the next, execute the following protocol:\n1.  **Run Command (Review State):** `python3 todo_manager.py show docker_arch_impl_20250810`\n2.  **Run Command (Mark Complete):** `python3 todo_manager.py done docker_arch_impl_20250810 1`\n3.  **Analyze Next Phase:** Before proceeding, read and understand the 'Explanations' and 'Tasks' for Phase 2.\n\n──────────────────────────────────\nIMPORTANT NOTE: The stability of the entire system depends on these foundational images. Any errors here will propagate to all services. Double-check CUDA versions and Python dependencies before proceeding.",
        "done": false
      },
      {
        "text": "PHASE 2: DEPENDENCY AUDIT & SPECIALIZED IMAGE REFINEMENT\n\n**Explanations:**\nAs per blueprint §H.2, we must ensure that specialized GPU images (`family-torch` and `family-vision`) contain all necessary system-level libraries (e.g., for audio/video processing) without bloating the more common CPU images.\n\n**Technical Artifacts / Tasks:**\n1.  **Perform Static Analysis:** For services in the `family-torch-cu121` and `family-vision-cu121` groups (see Fleet Table §F), perform a dependency audit.\n    *   Use static code scanning to identify Python library imports.\n    *   Use `ldd` on compiled binaries or `.so` files within those libraries to find system library dependencies (e.g., `ffmpeg`, `libpulse`, `libgl1`).\n2.  **Update Base Images (If Necessary):** If the audit reveals missing system libraries, update the Dockerfiles for `family-torch-cu121` and/or `family-vision-cu121` to include them via `apt-get install`.\n3.  **Rebuild and Push:** If any changes were made, rebuild and push the affected images, incrementing the date tag.\n\n**Concluding Step: Phase Completion Protocol**\nTo formally conclude this phase, update the plan's state, and prepare for the next, execute the following protocol:\n1.  **Run Command (Review State):** `python3 todo_manager.py show docker_arch_impl_20250810`\n2.  **Run Command (Mark Complete):** `python3 todo_manager.py done docker_arch_impl_20250810 2`\n3.  **Analyze Next Phase:** Before proceeding, read and understand the 'Explanations' and 'Tasks' for Phase 3.\n\n──────────────────────────────────\nIMPORTANT NOTE: This phase is a precision task. The goal is to add *only* the required libraries to the specialized images to maintain the principle of minimal layers.",
        "done": false
      },
      {
        "text": "PHASE 3: IMPLEMENT CI/CD AUTOMATION PIPELINE\n\n**Explanations:**\nThis phase automates the build, test, and deployment process using GitHub Actions, as outlined in blueprint sections A.6 and C. This pipeline will enforce quality gates and ensure reproducibility.\n\n**Technical Artifacts / Tasks:**\n1.  **Configure GHA Matrix Build:** Create a GitHub Actions workflow that uses a build matrix for `family` × `machine` combinations.\n2.  **Implement Registry Caching:** Configure `docker buildx` within the GHA workflow to use the registry for caching, as specified in the blueprint:\n    ```\n    --cache-to type=registry,ref=ghcr.io/<org>/cache\n    --cache-from type=registry,ref=ghcr.io/<org>/cache\n    ```\n3.  **Integrate Vulnerability Scanning:** Add a Trivy scan step to the pipeline. The step MUST be configured to `fail on HIGH/CRITICAL` severities.\n4.  **Implement SBOM Generation:** Add a step to the workflow that generates a Software Bill of Materials (SBOM) for each built image and uploads it as a build artifact.\n\n**Concluding Step: Phase Completion Protocol**\nTo formally conclude this phase, update the plan's state, and prepare for the next, execute the following protocol:\n1.  **Run Command (Review State):** `python3 todo_manager.py show docker_arch_impl_20250810`\n2.  **Run Command (Mark Complete):** `python3 todo_manager.py done docker_arch_impl_20250810 3`\n3.  **Analyze Next Phase:** Before proceeding, read and understand the 'Explanations' and 'Tasks' for Phase 4.\n\n──────────────────────────────────\nIMPORTANT NOTE: The CI pipeline is the factory floor for all services. Ensure it is robust and that failure conditions (like Trivy scans) are properly enforced before migrating services.",
        "done": false
      },
      {
        "text": "PHASE 4: PHASED SERVICE MIGRATION\n\n**Explanations:**\nThis is the largest phase, involving the migration of all ~50 services to the new Docker architecture. The migration is broken into sub-phases to manage complexity and risk, as per blueprint §H.4. For each service, you must create a new Dockerfile following the canonical patterns in §E, implement the health check from §C, and use the hardware profiles from §D.\n\n**Technical Artifacts / Tasks:**\n1.  **Sub-Phase 4.1 (Core Infrastructure):** Migrate the following services.\n    *   `ServiceRegistry`\n    *   `SystemDigitalTwin`\n    *   `UnifiedSystemAgent`\n    *   `SelfHealingSupervisor`\n    *   `UnifiedObservabilityCenter` & `(pc2)`\n    *   `CentralErrorBus`\n2.  **Sub-Phase 4.2 (MainPC 4090 GPU Services):** Migrate the GPU-heavy services on the main machine.\n    *   `ModelOpsCoordinator`\n    *   `AffectiveProcessingCenter`\n    *   `RealTimeAudioPipeline`\n    *   `TinyLlamaServiceEnhanced`\n    *   `ChainOfThoughtAgent`, `CognitiveModelAgent`, `LearningOpportunityDetector`, `LearningManager`, `DynamicIdentityAgent`, `ProactiveAgent`\n    *   `FaceRecognitionAgent`\n    *   `Responder`, `EmotionSynthesisAgent`, `STTService`, `TTSService`, `StreamingSpeechRecognition`, `StreamingTTSAgent`, `EmpathyAgent`\n3.  **Sub-Phase 4.3 (PC2 3060 Services):** Migrate all services designated for the second machine.\n    *   `RealTimeAudioPipelinePC2`\n    *   `VisionProcessingAgent`, `DreamWorldAgent`, `DreamingModeAgent`\n    *   `SpeechRelayService`\n    *   All other CPU services listed for PC2 (e.g., `TieredResponder`, `ResourceManager`, `TaskScheduler`, etc.)\n4.  **Sub-Phase 4.4 (Legacy & Remaining CPU Services):** Migrate the remaining services, including those on the legacy Python 3.10 base.\n    *   `IntentionValidatorAgent`, `NLUAgent`, `AdvancedCommandHandler`, `ChitchatAgent`\n    *   All other CPU services on the 4090 machine (e.g., `MemoryFusionHub`, `CodeGenerator`, `Executor`, etc.)\n\n**Concluding Step: Phase Completion Protocol**\nTo formally conclude this phase, update the plan's state, and prepare for the next, execute the following protocol:\n1.  **Run Command (Review State):** `python3 todo_manager.py show docker_arch_impl_20250810`\n2.  **Run Command (Mark Complete):** `python3 todo_manager.py done docker_arch_impl_20250810 4`\n3.  **Analyze Next Phase:** Before proceeding, read and understand the 'Explanations' and 'Tasks' for Phase 5.\n\n──────────────────────────────────\nIMPORTANT NOTE: This phase involves modifying the runtime of every service. Coordinate deployments carefully, especially for core infrastructure, to minimize downtime. Use the `FORCE_IMAGE_TAG` environment variable for targeted testing.",
        "done": false
      },
      {
        "text": "PHASE 5: OBSERVABILITY & TRACEABILITY INTEGRATION\n\n**Explanations:**\nTo achieve full system awareness, each service must report its identity and build information to the `UnifiedObservabilityCenter` upon startup, as per blueprint §H.5.\n\n**Technical Artifacts / Tasks:**\n1.  **Modify Service Entrypoints:** For every service migrated in Phase 4, modify its startup script (e.g., `entrypoint.sh`).\n2.  **Implement Reporting Logic:** The script should read the image's SBOM and the Git SHA (passed as an environment variable from the CI pipeline) and emit this data to the `UnifiedObservabilityCenter`'s API endpoint.\n3.  **Verify Integration:** After deploying a service, check the `UnifiedObservabilityCenter` logs or dashboard to confirm it has received the startup report.\n\n**Concluding Step: Phase Completion Protocol**\nTo formally conclude this phase, update the plan's state, and prepare for the next, execute the following protocol:\n1.  **Run Command (Review State):** `python3 todo_manager.py show docker_arch_impl_20250810`\n2.  **Run Command (Mark Complete):** `python3 todo_manager.py done docker_arch_impl_20250810 5`\n3.  **Analyze Next Phase:** Before proceeding, read and understand the 'Explanations' and 'Tasks' for Phase 6.\n\n───────────────────\nIMPORTANT NOTE: This step is crucial for runtime security and debugging. Knowing exactly which version of code is running in every container is non-negotiable for a production-grade system.",
        "done": false
      },
      {
        "text": "PHASE 6: FINALIZE ROLLBACK PROCEDURES & DOCUMENTATION\n\n**Explanations:**\nThe final phase is to formalize the safety net. This involves documenting the rollback process and ensuring the previous stable images are preserved correctly, as outlined in blueprint §H.6.\n\n**Technical Artifacts / Tasks:**\n1.  **Tag Previous Images:** Identify the last-known-good production images for all services (before this project began) and tag them with a `-prev` suffix in the container registry. This provides a definitive fallback point.\n2.  **Create Rollback Runbook:** Create a markdown document (`ROLLBACK_PROCEDURE.md`) in the main repository.\n3.  **Document Procedure:** The runbook must detail the exact steps to roll a service back to its `-prev` version, primarily by setting the `FORCE_IMAGE_TAG` environment variable in the deployment supervisor.\n4.  **Final System Review:** Conduct a full system health check. Ensure all services are running, reporting to the observability center, and communicating correctly.\n\n**Concluding Step: Plan Completion Protocol**\nTo formally conclude the entire plan and mark it as complete, execute the following protocol:\n1.  **Run Command (Review State):** `python3 todo_manager.py show docker_arch_impl_20250810`\n2.  **Run Command (Mark Complete):** `python3 todo_manager.py done docker_arch_impl_20250810 6`\n\n──────────────────────────────────\nIMPORTANT NOTE: This final phase ensures the project is not only complete but also maintainable and resilient. A well-documented rollback plan is a critical piece of operational readiness.",
        "done": false
      }
    ],
    "status": "in_progress",
    "created": "2025-08-10T08:01:15Z",
    "updated": "2025-08-10T16:20:24.028137+08:00"
  }
]