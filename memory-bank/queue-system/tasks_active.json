[
  {
    "id": "2024_master_bug_remediation",
    "description": "A prioritized action plan to fix critical, high, medium, and low severity bugs as detailed in the consolidated Master Bug Report.",
    "todos": [
      {
        "text": "PHASE 0: SETUP & PROTOCOL (READ FIRST)\n\n**Core Behavioral Mandates**\n*   **Execute Sequentially:** Phases are ordered by severity (Critical → High → Medium → Low). Do not skip phases. The system's stability depends on fixing critical issues first.\n*   **Verify Rigorously:** Each task includes a `Proposed Fix`. Do not mark a phase complete until all fixes are implemented and have passed relevant tests.\n*   **Consult Context:** Each task includes `Root Cause & Impact` to provide a deep understanding of the bug, helping to prevent regressions.\n\n**How-To/Workflow Protocol**\nThis plan is managed by a script, `todo_manager.py`.\n1.  **To Show Plan State:** `python3 todo_manager.py show 2024_master_bug_remediation`\n2.  **To Mark a Phase Complete:** `python3 todo_manager.py done 2024_master_bug_remediation [phase_index]` (e.g., `... done 2024_master_bug_remediation 0` for this phase).\n3.  **Follow the Protocol:** At the end of each phase, you will find a `Concluding Step` protocol. Follow it exactly to maintain plan integrity.\n\n**Concluding Step: Phase Completion Protocol**\nTo formally conclude this phase, update the plan's state, and prepare for the next, execute the following protocol:\n1.  **Run Command (Mark Complete):** `python3 todo_manager.py done 2024_master_bug_remediation 0`\n2.  **Analyze Next Phase:** Before proceeding, read and understand the 'Context' and 'Technical Artifacts' for Phase 1.\n\n──────────────────────────────────\nIMPORTANT NOTE: This phase contains the operating manual for this entire remediation plan. Completing it signifies your understanding of the process. Failure to follow the protocol can lead to incorrect state tracking.",
        "done": true
      },
      {
        "text": "PHASE 1: CRITICAL BUGS\n\n**Task 1: Fix ZMQ REP socket pool misuse, undefined endpoints, and context misuse**\n*   **Context (Root Cause & Impact):** Pool helpers bind REP sockets by default, but agents are binding them again, causing `Address already in use` errors. Furthermore, some agents overwrite `self.context` with `None` or use an undefined `self.endpoint`, leading to `AttributeError` crashes. This results in widespread agent startup failures and service unavailability.\n*   **Technical Artifacts / Tasks:**\n    *   **The Bug:** Agents obtain already-bound REP sockets and bind them again, use undefined endpoints, and/or nullify the ZMQ context before use.\n    *   **Location(s):**\n        *   `common/pools/zmq_pool.py`: 123-129, 398-402\n        *   `main_pc_code/agents/emotion_engine.py`: 122-146\n        *   `main_pc_code/agents/emotion_engine_enhanced.py`: 141-160\n        *   `main_pc_code/agents/chitchat_agent.py`: 79-86\n        *   `main_pc_code/agents/nlu_agent.py`: 147-153\n        *   `main_pc_code/agents/face_recognition_agent.py`: 484-494\n        *   `main_pc_code/agents/executor.py`: 121-129\n    *   **Proposed Fix:** For server-side REP sockets, stop using the pooled `get_rep_socket` helper. Instead, create sockets directly via `self.context.socket(zmq.REP)` and bind them once. Do not overwrite `self.context`. Ensure `self.endpoint` is defined before use or remove the reference if unnecessary.\n\n**Task 2: Remediate untrusted deserialization with pickle (RCE risk)**\n*   **Context (Root Cause & Impact):** The use of `pickle.loads` on untrusted network data is a severe security vulnerability. A specially crafted message can execute arbitrary commands on the host machine, leading to a full system compromise.\n*   **Technical Artifacts / Tasks:**\n    *   **The Bug:** Network messages are deserialized via the unsafe `pickle.loads` function.\n    *   **Location(s):**\n        *   `main_pc_code/agents/fused_audio_preprocessor.py`: 709-713\n        *   `main_pc_code/agents/streaming_interrupt_handler.py`: 226-228\n    *   **Proposed Fix:** Replace `pickle` with a safe serialization format like JSON or MsgPack. Strictly validate the schema of all incoming data. Consider adding message authentication (e.g., HMAC) if the channel is untrusted.\n\n**Task 3: Fix asyncio task creation with synchronous methods in ModelOps app**\n*   **Context (Root Cause & Impact):** The `asyncio.create_task()` function requires a coroutine (an `async def` function). The code is passing regular synchronous functions (`start()`), which return `None`. This raises a `TypeError` at startup, preventing the ModelOps Coordinator service from booting entirely.\n*   **Technical Artifacts / Tasks:**\n    *   **The Bug:** `asyncio.create_task()` is called with synchronous `start()` methods.\n    *   **Location(s):**\n        *   `model_ops_coordinator/app.py`: 247-252, 260-263\n        *   `model_ops_coordinator/transport/grpc_server.py`: 336-376\n        *   `model_ops_coordinator/transport/rest_api.py`: 503-518\n    *   **Proposed Fix:** Either convert the `start()` methods to `async def` or wrap the synchronous calls using `loop.run_in_executor(None, self.server.start)`.\n\n**Concluding Step: Phase Completion Protocol**\nTo formally conclude this phase, update the plan's state, and prepare for the next, execute the following protocol:\n1.  **Run Command (Review State):** `python3 todo_manager.py show 2024_master_bug_remediation`\n2.  **Run Command (Mark Complete):** `python3 todo_manager.py done 2024_master_bug_remediation 1`\n3.  **Analyze Next Phase:** Before proceeding, read and understand the 'Context' and 'Technical Artifacts' for Phase 2.\n\n──────────────────────────────────\nIMPORTANT NOTE: The bugs in this phase are critical. They cause agents to crash on startup or introduce severe remote code execution vulnerabilities. The system is unstable and insecure until this phase is complete.",
        "done": true
      },
      {
        "text": "PHASE 2: HIGH-SEVERITY BUGS\n\n**Task 4: Fix invalid ErrorPublisher PUB socket pattern**\n*   **Context (Root Cause & Impact):** The `ErrorPublisher` gets a PUB socket from a pool that binds it to an endpoint, but then the code attempts to `connect()` with it. A PUB socket should either bind (if it's a central collector) or connect (if it's a publisher), but not both. Binding to a remote endpoint will fail, silently disabling the entire error reporting bus.\n*   **Technical Artifacts / Tasks:**\n    *   **The Bug:** A pooled, bound PUB socket is then used with `.connect()`.\n    *   **Location(s):**\n        *   `main_pc_code/agents/error_publisher.py`: 41-52\n        *   `common/pools/zmq_pool.py`: 123-129, 404-408\n    *   **Proposed Fix:** Create a plain PUB socket with `zmq.Context.instance().socket(zmq.PUB)` and only call `.connect(self.endpoint)`. Alternatively, modify the pool helper to support a `bind=False` option for publisher sockets.\n\n**Task 5: Remediate code injection risk from `eval()` in metrics alerts**\n*   **Context (Root Cause & Impact):** Using `eval()` on dynamically constructed strings is a major security risk. A misconfiguration or a maliciously crafted alert condition can lead to arbitrary code execution, causing instability or system compromise.\n*   **Technical Artifacts / Tasks:**\n    *   **The Bug:** Alert conditions are checked using `eval()`.\n    *   **Location(s):** `common/observability/metrics.py`: 60-66\n    *   **Proposed Fix:** Do not use `eval()`. Parse the condition string safely. For example, use a regular expression to extract the operator (e.g., '>', '==', '<') and the value, then use the safe `operator` module (e.g., `operator.gt`, `operator.eq`) to perform the comparison.\n\n**Task 6: Fix mixed sync/async calls in shutdown path**\n*   **Context (Root Cause & Impact):** The shutdown logic attempts to `await asyncio.gather()` on a list of tasks that contains the results of synchronous `stop()` calls. Since sync functions return `None` (not a coroutine), this raises a `TypeError`, preventing a graceful shutdown and potentially leaving orphaned processes or resources.\n*   **Technical Artifacts / Tasks:**\n    *   **The Bug:** `asyncio.gather()` is called with non-awaitable results from synchronous functions.\n    *   **Location(s):**\n        *   `model_ops_coordinator/app.py`: 290-299\n        *   `model_ops_coordinator/transport/grpc_server.py`: 377-407\n        *   `model_ops_coordinator/transport/rest_api.py`: 533-546\n    *   **Proposed Fix:** Make the `stop()` methods `async def`, or wrap the synchronous calls in `loop.run_in_executor` before passing them to `gather`.\n\n**Task 7: Secure REST API (Fail-closed auth and restricted CORS)**\n*   **Context (Root Cause & Impact):** The API is \"fail-open\": if an API key isn't configured, authentication is simply disabled. Combined with a wildcard CORS policy (`allow_origins=[\"*\"]`), this exposes the entire ModelOps API to unauthenticated control from any website, a major security flaw.\n*   **Technical Artifacts / Tasks:**\n    *   **The Bug:** Auth is disabled when `api_key` is missing, and CORS is open to all origins.\n    *   **Location(s):** `model_ops_coordinator/transport/rest_api.py`: 190-197, 220-224\n    *   **Proposed Fix:** The API must be \"fail-closed\". If the API key is missing in a production environment, the application should refuse to start or reject all requests by default. Restrict `allow_origins` to a specific list of trusted domains.\n\n**Concluding Step: Phase Completion Protocol**\nTo formally conclude this phase, update the plan's state, and prepare for the next, execute the following protocol:\n1.  **Run Command (Review State):** `python3 todo_manager.py show 2024_master_bug_remediation`\n2.  **Run Command (Mark Complete):** `python3 todo_manager.py done 2024_master_bug_remediation 2`\n3.  **Analyze Next Phase:** Before proceeding, read and understand the 'Context' and 'Technical Artifacts' for Phase 3.\n\n──────────────────────────────────\nIMPORTANT NOTE: This phase addresses high-severity security vulnerabilities and architectural flaws. Completing it is essential for securing the system and ensuring its long-term stability.",
        "done": true
      },
      {
        "text": "PHASE 3: MEDIUM-SEVERITY BUGS\n\n**Task 8: Ensure GPU lease-sweeper thread is joined on shutdown**\n*   **Context (Root Cause & Impact):** The sweeper thread, which reclaims GPU resources, is signaled to stop but is never explicitly joined. This creates a race condition during interpreter shutdown, which can lead to incomplete VRAM accounting or unclean exits.\n*   **Technical Artifacts / Tasks:**\n    *   **The Bug:** The sweeper thread is not joined.\n    *   **Location(s):** `model_ops_coordinator/transport/grpc_server.py`: 49-51 (start), 399-405 (stop without join)\n    *   **Proposed Fix:** After setting the stop event (`self.servicer._lease_sweeper_stop.set()`), call `self.servicer._lease_sweeper.join(timeout=5)` to wait for the thread to finish.\n\n**Task 9: Fix data race on shared `voice_buffer` list**\n*   **Context (Root Cause & Impact):** Multiple threads are accessing and modifying the `self.voice_buffer` list without any synchronization. A `len()` check can pass, but another thread can `pop(0)` the last item before the first thread does, causing an `IndexError` and data loss.\n*   **Technical Artifacts / Tasks:**\n    *   **The Bug:** Unsynchronized access to a shared list from multiple threads.\n    *   **Location(s):** `main_pc_code/agents/face_recognition_agent.py`: 200-208\n    *   **Proposed Fix:** Replace the standard `list` with the thread-safe `queue.Queue()`, or protect all access to the list (appends, pops, checks) with a `threading.Lock()`.\n\n**Task 10: Remove silent error swallowing in machine auto-detection**\n*   **Context (Root Cause & Impact):** A bare `except: pass` block is used during GPU/machine detection. This is dangerous because it hides all underlying errors, including critical ones like `FileNotFoundError` or security exceptions. This makes debugging extremely difficult.\n*   **Technical Artifacts / Tasks:**\n    *   **The Bug:** A bare `except: pass` hides all exceptions.\n    *   **Location(s):** `common/utils/unified_config_loader.py`: 97-105\n    *   **Proposed Fix:** Catch only the specific exceptions you expect (e.g., `subprocess.CalledProcessError`, `FileNotFoundError`). Log any caught exceptions clearly with their traceback, and then either re-raise them or return an explicit fallback value.\n\n**Concluding Step: Phase Completion Protocol**\nTo formally conclude this phase, update the plan's state, and prepare for the next, execute the following protocol:\n1.  **Run Command (Review State):** `python3 todo_manager.py show 2024_master_bug_remediation`\n2.  **Run Command (Mark Complete):** `python3 todo_manager.py done 2024_master_bug_remediation 3`\n3.  **Analyze Next Phase:** Before proceeding, read and understand the 'Context' and 'Technical Artifacts' for Phase 4.\n\n──────────────────────────────────\nIMPORTANT NOTE: These medium-severity bugs relate to race conditions and poor error handling. Fixing them will improve the system's robustness, thread safety, and debuggability.",
        "done": true
      },
      {
        "text": "PHASE 4: LOW-SEVERITY BUGS\n\n**Task 11: Reduce TTL reaper cadence to prevent transient VRAM over-allocation**\n*   **Context (Root Cause & Impact):** The lease sweeper runs only once per second. In scenarios with rapid model loading/unloading, this coarse window can allow the total allocated VRAM to temporarily exceed the soft cap for up to 999ms, potentially causing an Out-Of-Memory (OOM) error on GPUs with limited VRAM.\n*   **Technical Artifacts / Tasks:**\n    *   **The Bug:** The 1.0s sweeper interval is too long.\n    *   **Location(s):** `model_ops_coordinator/transport/grpc_server.py`: 269-276\n    *   **Proposed Fix:** Reduce the sleep interval to a smaller value (e.g., 0.1 seconds) or implement a VRAM reservation system that keeps a small percentage of VRAM as a buffer.\n\n**Task 12: Add shutdown checks to infinite background loops**\n*   **Context (Root Cause & Impact):** Many background threads and utility exporters use a `while True:` loop without any mechanism to stop them. This means they will ignore shutdown signals, causing the main process to hang or be forcefully killed, preventing a clean exit.\n*   **Technical Artifacts / Tasks:**\n    *   **The Bug:** `while True:` loops lack a stop condition.\n    *   **Location(s) (representative):** `main_pc_code/agents/face_recognition_agent.py`: 200-208\n    *   **Proposed Fix:** In each loop, check a `threading.Event` or a boolean flag (e.g., `while not stop_event.is_set():`). Ensure the loop includes a short `time.sleep()` to prevent busy-waiting and allow the event to be processed.\n\n**Concluding Step: Plan Completion Protocol**\nTo formally conclude this plan, update its state by executing the following protocol:\n1.  **Run Command (Review State):** `python3 todo_manager.py show 2024_master_bug_remediation`\n2.  **Run Command (Mark Complete):** `python3 todo_manager.py done 2024_master_bug_remediation 4`\n\n──────────────────────────────────\nIMPORTANT NOTE: This final phase addresses low-severity bugs that improve resource management and ensure graceful shutdowns. Completing this phase finalizes the stabilization effort.",
        "done": true
      }
    ],
    "status": "completed",
    "created": "2024-05-24T12:00:00Z",
    "updated": "2025-08-09T21:56:10.299339+08:00"
  }
]