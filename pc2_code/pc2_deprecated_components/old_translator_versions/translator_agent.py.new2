class TranslatorAgent:
    """Enhanced Agent for translating Filipino commands to English using tiered approach with fallbacks"""
    def __init__(self):
        # Initialize ZMQ
        self.context = zmq.Context()
        
        # Socket to subscribe to listener
        try:
            self.listener_sub = self.context.socket(zmq.SUB)
            self.listener_sub.connect(f"tcp://localhost:{LISTENER_PORT}")
            self.listener_sub.setsockopt_string(zmq.SUBSCRIBE, "")
            self.listener_sub.setsockopt(zmq.RCVTIMEO, 5000)  # 5 second timeout
            logger.info(f"Connected to Listener on port {LISTENER_PORT}")
        except Exception as e:
            logger.error(f"Error connecting to Listener: {e}")
            raise RuntimeError(f"Cannot connect to Listener: {e}") from e
        
        # Socket to communicate with model manager for LLM-based translation
        try:
            self.model_manager = self.context.socket(zmq.REQ)
            self.model_manager.connect(f"tcp://localhost:{MODEL_MANAGER_PORT}")
            self.model_manager.setsockopt(zmq.RCVTIMEO, 10000)  # 10 second timeout
            logger.info(f"Connected to Model Manager on port {MODEL_MANAGER_PORT}")
        except Exception as e:
            logger.error(f"Error connecting to Model Manager: {e}")
            raise RuntimeError(f"Cannot connect to Model Manager: {e}") from e
        
        # Socket to communicate with NLLB Translation Adapter
        try:
            self.nllb_adapter = self.context.socket(zmq.REQ)
            self.nllb_adapter.connect(f"tcp://localhost:{NLLB_ADAPTER_PORT}")
            self.nllb_adapter.setsockopt(zmq.RCVTIMEO, 10000)  # 10 second timeout
            logger.info(f"Connected to NLLB Translation Adapter on port {NLLB_ADAPTER_PORT}")
        except Exception as e:
            logger.error(f"Error connecting to NLLB Adapter: {e}")
            logger.warning("NLLB Adapter connection failed, will skip this fallback method")
        
        # Socket to handle health check requests
        try:
            self.health_socket = self.context.socket(zmq.REP)
            self.health_socket.bind(f"tcp://127.0.0.1:{HEALTH_CHECK_PORT}")
            self.health_socket.setsockopt(zmq.RCVTIMEO, 100)  # 100ms timeout for non-blocking health checks
            logger.info(f"Health check socket bound to port {HEALTH_CHECK_PORT}")
        except zmq.error.ZMQError as e:
            logger.error(f"Error binding health check socket to port {HEALTH_CHECK_PORT}: {e}")
            # Don't raise an exception here, just log the error and continue
        
        # Statistics tracking
        self.stats = {
            "requests": 0,
            "google_translate_success": 0,
            "nllb_success": 0,
            "pattern_match_success": 0,
            "failures": 0,
            "last_error": None,
            "last_update": time.time(),
            "health_check_count": 0,
            "session_count": 0,
            "taglish_detected_count": 0,
            "english_skipped_count": 0,
            "avg_translation_time_ms": 0
        }
        
        # Session tracking
        self.sessions = {}
        
        # Running flag
        self.running = True
        
        # Configure connection timeouts
        socket.setdefaulttimeout(10)  # 10 seconds for HTTP requests
        
        logger.info("Translator Agent initialized with tiered translation approach")
        logger.info("Primary: Google Translate API, Fallback 1: NLLB adapter, Fallback 2: Pattern matching")
        
        # Log successful initialization
        self._log_status("Translator Agent started", "info")
        
    def _log_status(self, message, level="info"):
        """Log a status message with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_func = getattr(logger, level)
        log_func(f"[{timestamp}] {message}")
        
        # Update stats
        self.stats["last_update"] = time.time()
    
    def translate_command(self, text: str, source_lang="tl", target_lang="en") -> str:
        """Translate Filipino text to English using tiered approach with fallbacks"""
        start_time = time.time()
        self.stats["requests"] += 1
        
        try:
            # First, attempt to detect Taglish
            is_taglish, fil_ratio, eng_ratio = self._detect_taglish(text)
            if is_taglish:
                self.stats["taglish_detected_count"] += 1
                logger.info(f"[TranslatorAgent] Taglish detected: Filipino={fil_ratio:.2f}, English={eng_ratio:.2f}")
                # If mostly English, we might adjust our translation approach
                if eng_ratio > 0.7:
                    logger.info(f"Mostly English Taglish detected, skipping translation")
                    self.stats["english_skipped_count"] += 1
                    return text
            
            # Check if already English - skip translation
            if self._is_likely_english(text):
                logger.info(f"Text appears to be English already: '{text}'")
                self.stats["english_skipped_count"] += 1
                return text
                
            # Attempt 1: Google Translate API
            try:
                logger.debug(f"Attempting Google Translate API translation for: '{text}'")
                translated_text, success = self._google_translate(text, source_lang, target_lang)
                if success:
                    self.stats["google_translate_success"] += 1
                    logger.info(f"Google Translate succeeded: '{text}' -> '{translated_text}'")
                    
                    # Update stats with translation time
                    translation_time_ms = (time.time() - start_time) * 1000
                    self._update_avg_translation_time(translation_time_ms)
                    
                    return translated_text
                logger.warning("Google Translate failed, falling back to NLLB adapter")
            except Exception as e:
                logger.error(f"Error in Google Translate: {str(e)}")
                logger.warning("Google Translate failed, falling back to NLLB adapter")
            
            # Attempt 2: NLLB Adapter
            try:
                logger.debug(f"Attempting NLLB adapter translation for: '{text}'")
                translated_text, success = self._nllb_adapter_translation(text, source_lang, target_lang)
                if success:
                    self.stats["nllb_success"] += 1
                    logger.info(f"NLLB adapter succeeded: '{text}' -> '{translated_text}'")
                    
                    # Update stats with translation time
                    translation_time_ms = (time.time() - start_time) * 1000
                    self._update_avg_translation_time(translation_time_ms)
                    
                    return translated_text
                logger.warning("NLLB adapter failed, falling back to pattern matching")
            except Exception as e:
                logger.error(f"Error in NLLB adapter translation: {str(e)}")
                logger.warning("NLLB adapter failed, falling back to pattern matching")
            
            # Attempt 3: Pattern matching
            logger.debug(f"Attempting pattern matching for: '{text}'")
            translated_text = self._pattern_match_translation(text)
            if translated_text and translated_text != text:
                self.stats["pattern_match_success"] += 1
                logger.info(f"Pattern matching succeeded: '{text}' -> '{translated_text}'")
                
                # Update stats with translation time
                translation_time_ms = (time.time() - start_time) * 1000
                self._update_avg_translation_time(translation_time_ms)
                
                return translated_text
            
            # Final fallback: Return original text with failure flag
            self.stats["failures"] += 1
            logger.warning(f"All translation methods failed for: '{text}'")
            
            # Update stats with translation time
            translation_time_ms = (time.time() - start_time) * 1000
            self._update_avg_translation_time(translation_time_ms)
            
            return text
            
        except Exception as e:
            # Catch-all error handler
            self.stats["failures"] += 1
            logger.error(f"Unexpected error in translation: {str(e)}")
            traceback.print_exc()
            return text
    
    def _update_avg_translation_time(self, time_ms):
        """Update the average translation time in stats"""
        current_avg = self.stats["avg_translation_time_ms"]
        request_count = self.stats["requests"]
        
        if request_count <= 1:
            self.stats["avg_translation_time_ms"] = time_ms
        else:
            # Calculate running average
            self.stats["avg_translation_time_ms"] = current_avg + (time_ms - current_avg) / request_count
    
    def _detect_taglish(self, text):
        """Detect Taglish (mixed Filipino and English) in text"""
        try:
            # First try to import the specific taglish detector module if available
            try:
                from agents.taglish_detector import detect_taglish
                return detect_taglish(text)
            except ImportError:
                pass
            
            # Fallback implementation if module not available
            text_lower = text.lower()
            words = text_lower.split()
            
            # Filipino markers (common words and affixes)
            filipino_markers = [
                "ang", "ng", "mga", "sa", "ko", "mo", "niya", "namin", "natin", "ninyo", "nila",
                "ito", "iyan", "iyon", "dito", "diyan", "doon", "na", "pa", "pang-", "pag-", 
                "nag", "mag", "i-", "ka-", "makipag-", "nakipag-"
            ]
            
            # English markers (common words)
            english_markers = [
                "the", "a", "an", "is", "are", "was", "were", "has", "have", "had",
                "will", "would", "can", "could", "should", "may", "might", "must",
                "and", "or", "but", "if", "then", "else", "when", "while", "for"
            ]
            
            # Count Filipino and English markers
            fil_count = 0
            eng_count = 0
            
            for word in words:
                # Check if word contains Filipino markers
                for marker in filipino_markers:
                    if marker == word or word.startswith(marker) or word.endswith(marker):
                        fil_count += 1
                        break
                
                # Check if word is an English marker
                for marker in english_markers:
                    if marker == word:
                        eng_count += 1
                        break
            
            # Calculate ratios
            total = max(1, fil_count + eng_count)  # Avoid division by zero
            fil_ratio = fil_count / total
            eng_ratio = eng_count / total
            
            # Determine if Taglish (has both Filipino and English elements)
            is_taglish = fil_count > 0 and eng_count > 0
            
            return is_taglish, fil_ratio, eng_ratio
            
        except Exception as e:
            logger.error(f"Error in Taglish detection: {str(e)}")
            return False, 0, 0
    
    def _google_translate(self, text: str, source_lang="tl", target_lang="en") -> Tuple[str, bool]:
        """Translate text using Google Translate API"""
        try:
            # Prepare parameters
            params = {
                'client': 'gtx',
                'sl': source_lang,
                'tl': target_lang,
                'dt': 't',
                'q': text
            }
            
            # Make request
            response = requests.get(
                GOOGLE_TRANSLATE_URL,
                params=params,
                timeout=GOOGLE_TRANSLATE_TIMEOUT
            )
            
            # Check response
            if response.status_code != 200:
                logger.error(f"Google Translate API error: {response.status_code}")
                return text, False
            
            # Parse JSON response
            data = response.json()
            
            # Extract translation
            if not data or not isinstance(data, list) or len(data) < 1 or not isinstance(data[0], list):
                logger.error(f"Unexpected Google Translate response format: {data}")
                return text, False
            
            # Combine all translated segments
            translation = ""
            for segment in data[0]:
                if segment and len(segment) > 0:
                    translation += segment[0]
            
            if not translation:
                logger.error("Empty translation from Google Translate")
                return text, False
                
            return translation.strip(), True
            
        except requests.RequestException as e:
            logger.error(f"Google Translate request error: {str(e)}")
            return text, False
        except ValueError as e:
            logger.error(f"Google Translate JSON parsing error: {str(e)}")
            return text, False
        except Exception as e:
            logger.error(f"Unexpected error in Google Translate: {str(e)}")
            return text, False
