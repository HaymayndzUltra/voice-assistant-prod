#!/usr/bin/env python3
"""
Vulnerability Scanner - Automated Security Assessment
Provides comprehensive vulnerability scanning with bandit integration and security monitoring.

Features:
- Automated bandit security scanning with custom rules
- Security baseline management and drift detection  
- Dependency vulnerability scanning with CVE tracking
- Code quality and security metrics collection
- Integration with CI/CD pipelines for continuous security
- Real-time security alerts and remediation guidance
"""
from __future__ import annotations
import sys
import os
from pathlib import Path

# Add project root to path
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

import asyncio
import time
import json
import logging
import subprocess
import hashlib
import threading
from typing import Dict, List, Optional, Any, Tuple, Set
from dataclasses import dataclass, field, asdict
from datetime import datetime, timedelta
from collections import defaultdict, deque
from enum import Enum
import re

# Core imports
from common.core.base_agent import BaseAgent
from common_utils.error_handling import SafeExecutor

# Event system imports
from events.memory_events import (
    MemoryEventType, create_memory_operation, MemoryType
)
from events.event_bus import get_event_bus, publish_memory_event

class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class ScanType(Enum):
    """Types of security scans"""
    STATIC_ANALYSIS = "static_analysis"     # Code analysis (bandit)
    DEPENDENCY_SCAN = "dependency_scan"     # Package vulnerabilities
    SECRET_SCAN = "secret_scan"            # Hardcoded secrets
    COMPLIANCE_SCAN = "compliance_scan"     # Security compliance
    CUSTOM_RULES = "custom_rules"          # Custom security rules

class VulnerabilityStatus(Enum):
    """Vulnerability remediation status"""
    NEW = "new"
    ACKNOWLEDGED = "acknowledged"
    IN_PROGRESS = "in_progress"
    FIXED = "fixed"
    ACCEPTED_RISK = "accepted_risk"
    FALSE_POSITIVE = "false_positive"

@dataclass
class SecurityVulnerability:
    """Security vulnerability finding"""
    id: str
    scan_type: ScanType
    severity: VulnerabilitySeverity
    title: str
    description: str
    file_path: str
    line_number: Optional[int] = None
    rule_id: str = ""
    cve_id: Optional[str] = None
    cvss_score: Optional[float] = None
    confidence: str = "medium"
    status: VulnerabilityStatus = VulnerabilityStatus.NEW
    discovered_at: datetime = field(default_factory=datetime.now)
    updated_at: Optional[datetime] = None
    remediation_advice: str = ""
    
    @property
    def age_days(self) -> int:
        return (datetime.now() - self.discovered_at).days

@dataclass
class ScanResult:
    """Security scan result summary"""
    scan_id: str
    scan_type: ScanType
    started_at: datetime
    completed_at: Optional[datetime] = None
    status: str = "running"  # running, completed, failed
    total_files_scanned: int = 0
    total_vulnerabilities: int = 0
    vulnerabilities_by_severity: Dict[str, int] = field(default_factory=dict)
    scan_duration_seconds: Optional[float] = None
    error_message: Optional[str] = None

@dataclass
class SecurityBaseline:
    """Security baseline configuration"""
    baseline_id: str
    created_at: datetime
    total_vulnerabilities: int
    vulnerability_breakdown: Dict[str, int]
    acceptable_risk_level: VulnerabilitySeverity
    scan_configuration: Dict[str, Any]
    compliance_requirements: List[str] = field(default_factory=list)

class VulnerabilityScanner(BaseAgent):
    """
    Automated vulnerability scanning system.
    
    Provides comprehensive security assessment including static analysis,
    dependency scanning, and security compliance monitoring.
    """
    
    def __init__(self, 
                 scan_directories: Optional[List[str]] = None,
                 exclude_patterns: Optional[List[str]] = None,
                 enable_baseline_monitoring: bool = True,
                 **kwargs):
        super().__init__(name="VulnerabilityScanner", **kwargs)
        
        # Configuration
        self.scan_directories = scan_directories or [str(PROJECT_ROOT)]
        self.exclude_patterns = exclude_patterns or [
            "*/venv/*", "*/node_modules/*", "*/.git/*", "*/build/*", "*/dist/*",
            "*/__pycache__/*", "*.pyc", "*.log", "*/test_*", "*/tests/*"
        ]
        self.enable_baseline_monitoring = enable_baseline_monitoring
        
        # Vulnerability tracking
        self.vulnerabilities: Dict[str, SecurityVulnerability] = {}
        self.scan_history: List[ScanResult] = []
        self.baseline: Optional[SecurityBaseline] = None
        
        # Scanning state
        self.current_scans: Dict[str, ScanResult] = {}
        self.scan_schedule: Dict[ScanType, int] = {
            ScanType.STATIC_ANALYSIS: 3600,    # Every hour
            ScanType.DEPENDENCY_SCAN: 21600,   # Every 6 hours
            ScanType.SECRET_SCAN: 7200,        # Every 2 hours
            ScanType.COMPLIANCE_SCAN: 86400    # Daily
        }
        
        # Security metrics
        self.security_metrics = {
            'total_scans': 0,
            'vulnerabilities_found': 0,
            'vulnerabilities_fixed': 0,
            'mean_time_to_fix': 0.0,
            'security_score': 100.0
        }
        
        # Tools and configuration
        self.bandit_config = self._create_bandit_config()
        self.custom_rules = self._load_custom_security_rules()
        
        # Initialize components
        self._ensure_security_tools()
        self._start_scheduled_scanning()
        
        self.logger.info("Vulnerability Scanner initialized")
    
    def _create_bandit_config(self) -> Dict[str, Any]:
        """Create bandit configuration for security scanning"""
        return {
            'exclude_dirs': self.exclude_patterns,
            'skips': [],  # Test IDs to skip
            'tests': [],  # Specific tests to run (empty = all)
            'confidence': 'medium',  # low, medium, high
            'severity': 'low',      # low, medium, high
            'format': 'json',
            'aggregate': 'file',
            'msg_template': '{abspath}:{line}: [{severity}:{confidence}] {msg}',
            'include': ['*.py'],
            'exclude': []
        }
    
    def _load_custom_security_rules(self) -> List[Dict[str, Any]]:
        """Load custom security rules"""
        return [
            {
                'rule_id': 'HARDCODED_API_KEY',
                'pattern': r'(?i)(api_key|apikey|api-key)\s*[=:]\s*["\'][^"\']{20,}["\']',
                'severity': VulnerabilitySeverity.HIGH,
                'description': 'Hardcoded API key detected',
                'remediation': 'Move API keys to environment variables or secure credential storage'
            },
            {
                'rule_id': 'HARDCODED_PASSWORD',
                'pattern': r'(?i)(password|passwd|pwd)\s*[=:]\s*["\'][^"\']{8,}["\']',
                'severity': VulnerabilitySeverity.CRITICAL,
                'description': 'Hardcoded password detected',
                'remediation': 'Never hardcode passwords. Use secure credential management.'
            },
            {
                'rule_id': 'SQL_INJECTION_RISK',
                'pattern': r'(?i)(execute|query|cursor\.execute)\s*\(\s*["\'].*%.*["\']',
                'severity': VulnerabilitySeverity.HIGH,
                'description': 'Potential SQL injection vulnerability',
                'remediation': 'Use parameterized queries or prepared statements'
            },
            {
                'rule_id': 'DEBUG_MODE_ENABLED',
                'pattern': r'(?i)debug\s*[=:]\s*true',
                'severity': VulnerabilitySeverity.MEDIUM,
                'description': 'Debug mode enabled in production code',
                'remediation': 'Disable debug mode in production environments'
            },
            {
                'rule_id': 'INSECURE_RANDOM',
                'pattern': r'import\s+random|from\s+random\s+import',
                'severity': VulnerabilitySeverity.MEDIUM,
                'description': 'Use of insecure random number generator',
                'remediation': 'Use secrets module for cryptographically secure random numbers'
            }
        ]
    
    def _ensure_security_tools(self) -> None:
        """Ensure required security tools are available"""
        tools = {
            'bandit': 'pip install bandit',
            'safety': 'pip install safety',
            'semgrep': 'pip install semgrep'
        }
        
        missing_tools = []
        
        for tool, install_cmd in tools.items():
            try:
                result = subprocess.run(['which', tool], capture_output=True, text=True)
                if result.returncode != 0:
                    missing_tools.append((tool, install_cmd))
            except Exception:
                missing_tools.append((tool, install_cmd))
        
        if missing_tools:
            self.logger.warning(f"Missing security tools: {[tool for tool, _ in missing_tools]}")
            self.logger.info("Install with: " + "; ".join([cmd for _, cmd in missing_tools]))
    
    def _start_scheduled_scanning(self) -> None:
        """Start scheduled security scanning"""
        # Background scanning thread
        scan_thread = threading.Thread(target=self._scheduled_scan_loop, daemon=True)
        scan_thread.start()
        
        # Vulnerability monitoring thread
        monitor_thread = threading.Thread(target=self._vulnerability_monitoring_loop, daemon=True)
        monitor_thread.start()
        
        # Baseline drift detection thread
        drift_thread = threading.Thread(target=self._baseline_drift_loop, daemon=True)
        drift_thread.start()
    
    def _scheduled_scan_loop(self) -> None:
        """Background scheduled scanning loop"""
        last_scan_times = defaultdict(lambda: datetime.min)
        
        while self.running:
            try:
                current_time = datetime.now()
                
                for scan_type, interval_seconds in self.scan_schedule.items():
                    time_since_last = (current_time - last_scan_times[scan_type]).total_seconds()
                    
                    if time_since_last >= interval_seconds:
                        self.logger.info(f"Starting scheduled {scan_type.value} scan")
                        
                        # Run scan asynchronously
                        scan_task = threading.Thread(
                            target=self._run_scan_thread,
                            args=(scan_type,),
                            daemon=True
                        )
                        scan_task.start()
                        
                        last_scan_times[scan_type] = current_time
                
                time.sleep(60)  # Check every minute
                
            except Exception as e:
                self.logger.error(f"Scheduled scan error: {e}")
                time.sleep(300)
    
    def _vulnerability_monitoring_loop(self) -> None:
        """Monitor vulnerabilities and update metrics"""
        while self.running:
            try:
                self._update_security_metrics()
                self._check_vulnerability_sla()
                
                time.sleep(300)  # Every 5 minutes
                
            except Exception as e:
                self.logger.error(f"Vulnerability monitoring error: {e}")
                time.sleep(600)
    
    def _baseline_drift_loop(self) -> None:
        """Monitor for security baseline drift"""
        while self.running:
            try:
                if self.enable_baseline_monitoring and self.baseline:
                    self._check_baseline_drift()
                
                time.sleep(3600)  # Every hour
                
            except Exception as e:
                self.logger.error(f"Baseline drift monitoring error: {e}")
                time.sleep(1800)
    
    def _run_scan_thread(self, scan_type: ScanType) -> None:
        """Run a security scan in a separate thread"""
        try:
            asyncio.run(self.run_security_scan(scan_type))
        except Exception as e:
            self.logger.error(f"Scan thread error for {scan_type.value}: {e}")
    
    async def run_security_scan(self, scan_type: ScanType, target_directory: Optional[str] = None) -> ScanResult:
        """Run a comprehensive security scan"""
        scan_id = f"{scan_type.value}_{int(datetime.now().timestamp())}"
        target_dir = target_directory or self.scan_directories[0]
        
        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type=scan_type,
            started_at=datetime.now()
        )
        
        self.current_scans[scan_id] = scan_result
        
        try:
            self.logger.info(f"Starting {scan_type.value} scan: {scan_id}")
            
            if scan_type == ScanType.STATIC_ANALYSIS:
                vulnerabilities = await self._run_bandit_scan(target_dir)
            elif scan_type == ScanType.DEPENDENCY_SCAN:
                vulnerabilities = await self._run_dependency_scan(target_dir)
            elif scan_type == ScanType.SECRET_SCAN:
                vulnerabilities = await self._run_secret_scan(target_dir)
            elif scan_type == ScanType.COMPLIANCE_SCAN:
                vulnerabilities = await self._run_compliance_scan(target_dir)
            elif scan_type == ScanType.CUSTOM_RULES:
                vulnerabilities = await self._run_custom_rules_scan(target_dir)
            else:
                vulnerabilities = []
            
            # Update scan result
            scan_result.completed_at = datetime.now()
            scan_result.status = "completed"
            scan_result.total_vulnerabilities = len(vulnerabilities)
            scan_result.scan_duration_seconds = (
                scan_result.completed_at - scan_result.started_at
            ).total_seconds()
            
            # Count vulnerabilities by severity
            severity_counts = defaultdict(int)
            for vuln in vulnerabilities:
                severity_counts[vuln.severity.value] += 1
                
                # Store vulnerability
                self.vulnerabilities[vuln.id] = vuln
            
            scan_result.vulnerabilities_by_severity = dict(severity_counts)
            
            # Update metrics
            self.security_metrics['total_scans'] += 1
            self.security_metrics['vulnerabilities_found'] += len(vulnerabilities)
            
            # Publish scan completion event
            scan_event = create_memory_operation(
                operation_type=MemoryEventType.MEMORY_CREATED,
                memory_id=f"security_scan_{scan_id}",
                memory_type=MemoryType.PROCEDURAL,
                content=f"Security scan {scan_type.value} completed: {len(vulnerabilities)} vulnerabilities",
                size_bytes=len(str(vulnerabilities)),
                source_agent=self.name,
                machine_id=self._get_machine_id()
            )
            
            publish_memory_event(scan_event)
            
            self.logger.info(f"Scan {scan_id} completed: {len(vulnerabilities)} vulnerabilities found")
            
        except Exception as e:
            scan_result.status = "failed"
            scan_result.error_message = str(e)
            scan_result.completed_at = datetime.now()
            
            self.logger.error(f"Scan {scan_id} failed: {e}")
        
        finally:
            # Add to history and cleanup
            self.scan_history.append(scan_result)
            if scan_id in self.current_scans:
                del self.current_scans[scan_id]
        
        return scan_result
    
    async def _run_bandit_scan(self, target_directory: str) -> List[SecurityVulnerability]:
        """Run bandit static analysis scan"""
        vulnerabilities = []
        
        try:
            # Prepare bandit command
            cmd = [
                'bandit',
                '-r', target_directory,
                '-f', 'json',
                '-ll',  # Report only medium and high severity
                '--exclude', ','.join(self.exclude_patterns)
            ]
            
            # Execute bandit
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode in [0, 1]:  # 0 = no issues, 1 = issues found
                if stdout:
                    bandit_results = json.loads(stdout.decode())
                    
                    for result in bandit_results.get('results', []):
                        vuln = SecurityVulnerability(
                            id=self._generate_vulnerability_id(result),
                            scan_type=ScanType.STATIC_ANALYSIS,
                            severity=self._map_bandit_severity(result.get('issue_severity', 'MEDIUM')),
                            title=result.get('test_name', 'Unknown Security Issue'),
                            description=result.get('issue_text', ''),
                            file_path=result.get('filename', ''),
                            line_number=result.get('line_number'),
                            rule_id=result.get('test_id', ''),
                            confidence=result.get('issue_confidence', 'MEDIUM').lower(),
                            remediation_advice=self._get_bandit_remediation(result.get('test_id', ''))
                        )
                        
                        vulnerabilities.append(vuln)
            else:
                self.logger.error(f"Bandit scan failed: {stderr.decode()}")
                
        except FileNotFoundError:
            self.logger.warning("Bandit not found - install with: pip install bandit")
        except json.JSONDecodeError as e:
            self.logger.error(f"Failed to parse bandit output: {e}")
        except Exception as e:
            self.logger.error(f"Bandit scan error: {e}")
        
        return vulnerabilities
    
    async def _run_dependency_scan(self, target_directory: str) -> List[SecurityVulnerability]:
        """Run dependency vulnerability scan using safety"""
        vulnerabilities = []
        
        try:
            # Find requirements files
            requirements_files = []
            for req_file in ['requirements.txt', 'Pipfile', 'pyproject.toml']:
                req_path = Path(target_directory) / req_file
                if req_path.exists():
                    requirements_files.append(str(req_path))
            
            if not requirements_files:
                self.logger.debug("No requirements files found for dependency scan")
                return vulnerabilities
            
            # Run safety check
            cmd = ['safety', 'check', '--json']
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=target_directory
            )
            
            stdout, stderr = await process.communicate()
            
            if stdout:
                try:
                    safety_results = json.loads(stdout.decode())
                    
                    for result in safety_results:
                        vuln = SecurityVulnerability(
                            id=self._generate_vulnerability_id(result),
                            scan_type=ScanType.DEPENDENCY_SCAN,
                            severity=self._map_cvss_to_severity(result.get('cvss')),
                            title=f"Vulnerable dependency: {result.get('package', 'unknown')}",
                            description=result.get('advisory', ''),
                            file_path='requirements.txt',
                            cve_id=result.get('cve'),
                            cvss_score=result.get('cvss'),
                            remediation_advice=f"Update {result.get('package', 'package')} to version {result.get('safe_version', 'latest')}"
                        )
                        
                        vulnerabilities.append(vuln)
                        
                except json.JSONDecodeError:
                    # Safety might return non-JSON output when no vulnerabilities found
                    pass
                    
        except FileNotFoundError:
            self.logger.warning("Safety not found - install with: pip install safety")
        except Exception as e:
            self.logger.error(f"Dependency scan error: {e}")
        
        return vulnerabilities
    
    async def _run_secret_scan(self, target_directory: str) -> List[SecurityVulnerability]:
        """Run custom secret scanning"""
        vulnerabilities = []
        
        try:
            # Scan for secrets using custom rules
            for root, dirs, files in os.walk(target_directory):
                # Skip excluded directories
                dirs[:] = [d for d in dirs if not any(
                    pattern.replace('*', '').replace('/', '') in os.path.join(root, d)
                    for pattern in self.exclude_patterns
                )]
                
                for file in files:
                    if file.endswith(('.py', '.js', '.ts', '.json', '.yaml', '.yml', '.env')):
                        file_path = os.path.join(root, file)
                        
                        try:
                            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                content = f.read()
                                
                            vulnerabilities.extend(
                                self._scan_file_for_secrets(file_path, content)
                            )
                            
                        except Exception as e:
                            self.logger.debug(f"Could not scan file {file_path}: {e}")
                            
        except Exception as e:
            self.logger.error(f"Secret scan error: {e}")
        
        return vulnerabilities
    
    def _scan_file_for_secrets(self, file_path: str, content: str) -> List[SecurityVulnerability]:
        """Scan file content for hardcoded secrets"""
        vulnerabilities = []
        
        for rule in self.custom_rules:
            for match in re.finditer(rule['pattern'], content, re.MULTILINE):
                line_number = content[:match.start()].count('\n') + 1
                
                vuln = SecurityVulnerability(
                    id=self._generate_vulnerability_id({
                        'file': file_path,
                        'line': line_number,
                        'rule': rule['rule_id']
                    }),
                    scan_type=ScanType.SECRET_SCAN,
                    severity=rule['severity'],
                    title=rule['description'],
                    description=f"Found in: {match.group(0)[:50]}...",
                    file_path=file_path,
                    line_number=line_number,
                    rule_id=rule['rule_id'],
                    remediation_advice=rule['remediation']
                )
                
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _run_compliance_scan(self, target_directory: str) -> List[SecurityVulnerability]:
        """Run security compliance scan"""
        vulnerabilities = []
        
        # Check for security compliance requirements
        compliance_checks = [
            {
                'name': 'Missing security headers configuration',
                'check': lambda: self._check_security_headers(target_directory),
                'severity': VulnerabilitySeverity.MEDIUM
            },
            {
                'name': 'Insecure file permissions',
                'check': lambda: self._check_file_permissions(target_directory),
                'severity': VulnerabilitySeverity.HIGH
            },
            {
                'name': 'Missing security documentation',
                'check': lambda: self._check_security_documentation(target_directory),
                'severity': VulnerabilitySeverity.LOW
            }
        ]
        
        for check in compliance_checks:
            try:
                issues = check['check']()
                for issue in issues:
                    vuln = SecurityVulnerability(
                        id=self._generate_vulnerability_id(issue),
                        scan_type=ScanType.COMPLIANCE_SCAN,
                        severity=check['severity'],
                        title=check['name'],
                        description=issue.get('description', ''),
                        file_path=issue.get('file_path', ''),
                        remediation_advice=issue.get('remediation', '')
                    )
                    
                    vulnerabilities.append(vuln)
                    
            except Exception as e:
                self.logger.error(f"Compliance check '{check['name']}' failed: {e}")
        
        return vulnerabilities
    
    async def _run_custom_rules_scan(self, target_directory: str) -> List[SecurityVulnerability]:
        """Run custom security rules scan"""
        # This would run additional custom security rules
        # For now, return empty list as custom rules are covered in secret scan
        return []
    
    def _check_security_headers(self, target_directory: str) -> List[Dict[str, str]]:
        """Check for security headers configuration"""
        issues = []
        
        # Look for web framework configuration files
        config_files = []
        for root, dirs, files in os.walk(target_directory):
            for file in files:
                if file in ['app.py', 'main.py', 'server.py', 'wsgi.py']:
                    config_files.append(os.path.join(root, file))
        
        for config_file in config_files:
            try:
                with open(config_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Check for missing security headers
                security_headers = [
                    'X-Content-Type-Options',
                    'X-Frame-Options',
                    'X-XSS-Protection',
                    'Strict-Transport-Security'
                ]
                
                missing_headers = []
                for header in security_headers:
                    if header.lower() not in content.lower():
                        missing_headers.append(header)
                
                if missing_headers:
                    issues.append({
                        'description': f"Missing security headers: {', '.join(missing_headers)}",
                        'file_path': config_file,
                        'remediation': 'Add missing security headers to your web application configuration'
                    })
                    
            except Exception as e:
                self.logger.debug(f"Could not check security headers in {config_file}: {e}")
        
        return issues
    
    def _check_file_permissions(self, target_directory: str) -> List[Dict[str, str]]:
        """Check for insecure file permissions"""
        issues = []
        
        try:
            # Check for world-writable files
            for root, dirs, files in os.walk(target_directory):
                for file in files:
                    file_path = os.path.join(root, file)
                    
                    try:
                        stat_info = os.stat(file_path)
                        mode = stat_info.st_mode
                        
                        # Check if world-writable (mode & 0o002)
                        if mode & 0o002:
                            issues.append({
                                'description': f"World-writable file: {file_path}",
                                'file_path': file_path,
                                'remediation': 'Remove world-write permissions: chmod o-w filename'
                            })
                            
                    except Exception:
                        continue
                        
        except Exception as e:
            self.logger.error(f"File permission check error: {e}")
        
        return issues
    
    def _check_security_documentation(self, target_directory: str) -> List[Dict[str, str]]:
        """Check for security documentation"""
        issues = []
        
        # Look for security documentation files
        security_docs = ['SECURITY.md', 'security.md', 'SECURITY.rst', 'docs/security.md']
        
        found_docs = []
        for doc in security_docs:
            doc_path = Path(target_directory) / doc
            if doc_path.exists():
                found_docs.append(doc)
        
        if not found_docs:
            issues.append({
                'description': 'No security documentation found',
                'file_path': target_directory,
                'remediation': 'Create a SECURITY.md file documenting security policies and procedures'
            })
        
        return issues
    
    def _generate_vulnerability_id(self, data: Any) -> str:
        """Generate unique vulnerability ID"""
        content = json.dumps(data, sort_keys=True, default=str)
        return hashlib.md5(content.encode()).hexdigest()[:16]
    
    def _map_bandit_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map bandit severity to our severity levels"""
        mapping = {
            'LOW': VulnerabilitySeverity.LOW,
            'MEDIUM': VulnerabilitySeverity.MEDIUM,
            'HIGH': VulnerabilitySeverity.HIGH
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.MEDIUM)
    
    def _map_cvss_to_severity(self, cvss_score: Optional[float]) -> VulnerabilitySeverity:
        """Map CVSS score to vulnerability severity"""
        if not cvss_score:
            return VulnerabilitySeverity.MEDIUM
        
        if cvss_score >= 9.0:
            return VulnerabilitySeverity.CRITICAL
        elif cvss_score >= 7.0:
            return VulnerabilitySeverity.HIGH
        elif cvss_score >= 4.0:
            return VulnerabilitySeverity.MEDIUM
        else:
            return VulnerabilitySeverity.LOW
    
    def _get_bandit_remediation(self, test_id: str) -> str:
        """Get remediation advice for bandit test IDs"""
        remediation_map = {
            'B101': 'Avoid using assert statements in production code',
            'B102': 'Do not use exec() with user-supplied input',
            'B103': 'Set file permissions explicitly when creating files',
            'B104': 'Bind to specific interfaces instead of 0.0.0.0',
            'B105': 'Avoid hardcoded passwords in source code',
            'B106': 'Avoid hardcoded passwords in function arguments',
            'B107': 'Do not use shell=True with subprocess',
            'B108': 'Use secure temporary file creation methods',
            'B201': 'Avoid using pickle with untrusted data',
            'B301': 'Use secure random number generators for security purposes',
            'B302': 'Avoid using deprecated ssl contexts',
            'B303': 'Use secure hash algorithms (avoid MD5, SHA1)',
            'B501': 'Use secure SSL/TLS configuration',
            'B601': 'Avoid shell injection vulnerabilities',
            'B602': 'Use subprocess with shell=False',
            'B603': 'Validate subprocess arguments to prevent injection'
        }
        
        return remediation_map.get(test_id, 'Review code for security best practices')
    
    def _update_security_metrics(self) -> None:
        """Update security metrics"""
        # Calculate current security score
        total_vulns = len(self.vulnerabilities)
        critical_vulns = len([v for v in self.vulnerabilities.values() 
                             if v.severity == VulnerabilitySeverity.CRITICAL])
        high_vulns = len([v for v in self.vulnerabilities.values() 
                         if v.severity == VulnerabilitySeverity.HIGH])
        
        # Simple security score calculation
        if total_vulns == 0:
            security_score = 100.0
        else:
            # Penalty based on severity
            penalty = (critical_vulns * 20) + (high_vulns * 10) + ((total_vulns - critical_vulns - high_vulns) * 2)
            security_score = max(0, 100 - penalty)
        
        self.security_metrics['security_score'] = security_score
        
        # Calculate mean time to fix
        fixed_vulns = [v for v in self.vulnerabilities.values() 
                      if v.status == VulnerabilityStatus.FIXED and v.updated_at]
        
        if fixed_vulns:
            fix_times = [(v.updated_at - v.discovered_at).total_seconds() / 86400  # days
                        for v in fixed_vulns]
            self.security_metrics['mean_time_to_fix'] = sum(fix_times) / len(fix_times)
    
    def _check_vulnerability_sla(self) -> None:
        """Check vulnerability SLA compliance"""
        # Define SLA thresholds (days)
        sla_thresholds = {
            VulnerabilitySeverity.CRITICAL: 1,   # 1 day
            VulnerabilitySeverity.HIGH: 7,       # 1 week
            VulnerabilitySeverity.MEDIUM: 30,    # 1 month
            VulnerabilitySeverity.LOW: 90        # 3 months
        }
        
        overdue_vulns = []
        
        for vuln in self.vulnerabilities.values():
            if vuln.status in [VulnerabilityStatus.NEW, VulnerabilityStatus.ACKNOWLEDGED]:
                threshold = sla_thresholds.get(vuln.severity, 30)
                
                if vuln.age_days > threshold:
                    overdue_vulns.append(vuln)
        
        if overdue_vulns:
            self.logger.warning(f"{len(overdue_vulns)} vulnerabilities are overdue for remediation")
    
    def _check_baseline_drift(self) -> None:
        """Check for security baseline drift"""
        if not self.baseline:
            return
        
        current_vulns = len(self.vulnerabilities)
        baseline_vulns = self.baseline.total_vulnerabilities
        
        # Check for significant increase in vulnerabilities
        if current_vulns > baseline_vulns * 1.2:  # 20% increase
            self.logger.warning(f"Security baseline drift detected: {current_vulns} vs {baseline_vulns} baseline")
    
    def create_security_baseline(self) -> SecurityBaseline:
        """Create a new security baseline"""
        baseline_id = f"baseline_{int(datetime.now().timestamp())}"
        
        vulnerability_breakdown = defaultdict(int)
        for vuln in self.vulnerabilities.values():
            vulnerability_breakdown[vuln.severity.value] += 1
        
        baseline = SecurityBaseline(
            baseline_id=baseline_id,
            created_at=datetime.now(),
            total_vulnerabilities=len(self.vulnerabilities),
            vulnerability_breakdown=dict(vulnerability_breakdown),
            acceptable_risk_level=VulnerabilitySeverity.MEDIUM,
            scan_configuration=self.bandit_config.copy()
        )
        
        self.baseline = baseline
        self.logger.info(f"Security baseline created: {baseline_id}")
        
        return baseline
    
    def update_vulnerability_status(self, vulnerability_id: str, 
                                  status: VulnerabilityStatus, 
                                  notes: str = "") -> bool:
        """Update vulnerability status"""
        if vulnerability_id in self.vulnerabilities:
            vuln = self.vulnerabilities[vulnerability_id]
            old_status = vuln.status
            vuln.status = status
            vuln.updated_at = datetime.now()
            
            # Update metrics if fixed
            if status == VulnerabilityStatus.FIXED and old_status != VulnerabilityStatus.FIXED:
                self.security_metrics['vulnerabilities_fixed'] += 1
            
            self.logger.info(f"Vulnerability {vulnerability_id} status updated: {old_status.value} -> {status.value}")
            return True
        
        return False
    
    def get_security_report(self) -> Dict[str, Any]:
        """Get comprehensive security report"""
        # Vulnerability summary
        vuln_summary = defaultdict(int)
        status_summary = defaultdict(int)
        
        for vuln in self.vulnerabilities.values():
            vuln_summary[vuln.severity.value] += 1
            status_summary[vuln.status.value] += 1
        
        # Recent scans
        recent_scans = sorted(self.scan_history, key=lambda x: x.started_at, reverse=True)[:10]
        
        # Top vulnerabilities by severity
        top_vulns = sorted(
            self.vulnerabilities.values(),
            key=lambda x: (x.severity.value, -x.age_days),
            reverse=True
        )[:20]
        
        return {
            'security_metrics': self.security_metrics,
            'vulnerability_summary': {
                'total': len(self.vulnerabilities),
                'by_severity': dict(vuln_summary),
                'by_status': dict(status_summary)
            },
            'baseline': asdict(self.baseline) if self.baseline else None,
            'recent_scans': [
                {
                    'scan_id': scan.scan_id,
                    'scan_type': scan.scan_type.value,
                    'started_at': scan.started_at.isoformat(),
                    'status': scan.status,
                    'vulnerabilities_found': scan.total_vulnerabilities,
                    'duration_seconds': scan.scan_duration_seconds
                }
                for scan in recent_scans
            ],
            'top_vulnerabilities': [
                {
                    'id': vuln.id,
                    'severity': vuln.severity.value,
                    'title': vuln.title,
                    'file_path': vuln.file_path,
                    'age_days': vuln.age_days,
                    'status': vuln.status.value
                }
                for vuln in top_vulns
            ],
            'compliance_status': {
                'baseline_compliant': self._is_baseline_compliant(),
                'sla_violations': self._count_sla_violations()
            }
        }
    
    def _is_baseline_compliant(self) -> bool:
        """Check if current state is baseline compliant"""
        if not self.baseline:
            return True
        
        current_vulns = len(self.vulnerabilities)
        return current_vulns <= self.baseline.total_vulnerabilities
    
    def _count_sla_violations(self) -> int:
        """Count SLA violations"""
        sla_thresholds = {
            VulnerabilitySeverity.CRITICAL: 1,
            VulnerabilitySeverity.HIGH: 7,
            VulnerabilitySeverity.MEDIUM: 30,
            VulnerabilitySeverity.LOW: 90
        }
        
        violations = 0
        for vuln in self.vulnerabilities.values():
            if vuln.status in [VulnerabilityStatus.NEW, VulnerabilityStatus.ACKNOWLEDGED]:
                threshold = sla_thresholds.get(vuln.severity, 30)
                if vuln.age_days > threshold:
                    violations += 1
        
        return violations
    
    def _get_machine_id(self) -> str:
        """Get current machine identifier"""
        import socket
        hostname = socket.gethostname().lower()
        
        if "main" in hostname or ("pc" in hostname and "pc2" not in hostname):
            return "MainPC"
        elif "pc2" in hostname:
            return "PC2"
        else:
            return "MainPC"  # Default
    
    def shutdown(self):
        """Shutdown the vulnerability scanner"""
        # Clear scan data
        self.vulnerabilities.clear()
        self.current_scans.clear()
        
        super().shutdown()

if __name__ == "__main__":
    # Example usage
    import logging
    
    logging.basicConfig(level=logging.INFO)
    
    scanner = VulnerabilityScanner()
    
    try:
        # Run a manual scan
        scan_result = asyncio.run(scanner.run_security_scan(ScanType.STATIC_ANALYSIS))
        print(f"Scan completed: {scan_result.total_vulnerabilities} vulnerabilities found")
        
        # Generate security report
        report = scanner.get_security_report()
        print(json.dumps(report, indent=2, default=str))
        
        # Keep running for scheduled scans
        import time
        while True:
            time.sleep(60)
            
    except KeyboardInterrupt:
        print("Shutting down Vulnerability Scanner...")
        scanner.shutdown() 